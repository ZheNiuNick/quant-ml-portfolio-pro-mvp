{% extends "base.html" %}

{% block title %}Factor Diagnostics- Quantitative Trading Strategy Dashboard{% endblock %}

{% block extra_head %}
<style>
    .diagnostic-card {
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .metric-value {
        font-size: 1.5em;
        font-weight: bold;
    }
    .metric-label {
        color: #666;
        font-size: 0.9em;
    }
    .chart-container {
        height: 400px;
        margin-bottom: 20px;
    }
    #factor-cluster-chart {
        height: 600px !important;
    }
    .factor-category {
        padding: 10px;
        margin: 5px;
        border-radius: 5px;
        display: inline-block;
    }
    .momentum { background-color: #e3f2fd; }
    .quality { background-color: #f3e5f5; }
    .volatility { background-color: #fff3e0; }
    .value { background-color: #e8f5e9; }
    .size { background-color: #fce4ec; }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row mb-4">
        <div class="col-12">
            <h2 class="mb-0"><i class="fas fa-microscope me-2"></i>Factor Diagnostics</h2>
            <p class="text-muted">Factor evaluation, IC analysis, risk exposure and correlation analysis</p>
        </div>
    </div>

    <!-- Loading Status -->
    <div id="loading" class="text-center py-5">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-3">Loading factor diagnostics data...</p>
    </div>

    <!-- Error Message -->
    <div id="error-message" class="alert alert-danger" style="display: none;">
        <i class="fas fa-exclamation-triangle me-2"></i>
        <span id="error-text"></span>
    </div>

    <!-- Main Content -->
    <div id="main-content" style="display: none;">
        <!-- 1. Rolling IC Curve -->
        <div class="card diagnostic-card">
            <div class="card-header bg-primary text-white">
                <h5 class="mb-0"><i class="fas fa-chart-line me-2"></i>Rolling IC Curve (12 months)</h5>
            </div>
            <div class="card-body">
                <div id="rolling-ic-chart" class="chart-container"></div>
            </div>
        </div>

        <!-- 2. Rolling ICIR and t-stat -->
        <div class="row">
            <div class="col-md-6">
                <div class="card diagnostic-card">
                    <div class="card-header bg-info text-white">
                        <h5 class="mb-0"><i class="fas fa-chart-area me-2"></i>Rolling ICIR</h5>
                    </div>
                    <div class="card-body">
                        <div id="rolling-icir-chart" class="chart-container"></div>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card diagnostic-card">
                    <div class="card-header bg-warning text-dark">
                        <h5 class="mb-0"><i class="fas fa-chart-bar me-2"></i>Rolling t-stat</h5>
                    </div>
                    <div class="card-body">
                        <div id="rolling-tstat-chart" class="chart-container"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 3. Long-Short Portfolio Performance -->
        <div class="card diagnostic-card">
            <div class="card-header bg-success text-white">
                <h5 class="mb-0"><i class="fas fa-exchange-alt me-2"></i>Long-Short Portfolio Performance (by Factor)</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="factor-select" class="form-label">Select Factor:</label>
                    <select id="factor-select" class="form-select" onchange="loadLongShortPerformance()">
                        <option value="">Loading...</option>
                    </select>
                </div>
                <div id="long-short-chart" class="chart-container"></div>
                <div id="long-short-table" class="mt-3"></div>
            </div>
        </div>

        <!-- 4. Factor Clusters Analysis -->
        <div class="card diagnostic-card">
            <div class="card-header bg-secondary text-white">
                <h5 class="mb-0"><i class="fas fa-layer-group me-2"></i>Factor Clusters Analysis (Momentum / Quality / Volatility)</h5>
            </div>
            <div class="card-body">
                <div id="factor-cluster-chart" class="chart-container"></div>
                <div id="factor-cluster-table" class="mt-3"></div>
                <div id="factor-cluster-explanation"></div>
            </div>
        </div>

        <!-- 5. Factor Correlation Matrix -->
        <div class="card diagnostic-card">
            <div class="card-header bg-dark text-white">
                <h5 class="mb-0"><i class="fas fa-th me-2"></i>Factor Correlation Matrix</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="correlation-method" class="form-label">Correlation Method:</label>
                    <select id="correlation-method" class="form-select" onchange="loadCorrelationMatrix()">
                        <option value="pearson">Pearson</option>
                    </select>
                </div>
                <div id="correlation-matrix-chart" class="chart-container" style="height: 600px;"></div>
            </div>
        </div>

        <!-- 6. Multi-Factor Risk Exposure (Barra-style) -->
        <div class="card diagnostic-card">
            <div class="card-header bg-danger text-white">
                <h5 class="mb-0"><i class="fas fa-shield-alt me-2"></i>Multi-Factor Risk Exposure (Barra-style)</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="exposure-date" class="form-label">Select Date:</label>
                    <input type="date" id="exposure-date" class="form-control" onchange="loadRiskExposure()">
                </div>
                <div id="risk-exposure-chart" class="chart-container"></div>
                <div id="risk-exposure-table" class="mt-3"></div>
                <div id="risk-exposure-explanation"></div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    // API_BASE_URL is already declared in base.html, use it directly here

    // Initialize on page load
    function initPage() {
        console.log('Initializing page, DOM Status:', document.readyState);
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                console.log('DOMContentLoaded event triggered');
                setTimeout(() => loadAllDiagnostics(), 100);
            });
        } else {
            console.log('DOM ready, execute directly');
            setTimeout(() => loadAllDiagnostics(), 100);
        }
    }
    
    // Add timeout protection: if still loading after 10 seconds, force display content
    setTimeout(() => {
        const loadingEl = document.getElementById('loading');
        const mainContentEl = document.getElementById('main-content');
        if (loadingEl && loadingEl.style.display !== 'none') {
            console.warn('Loading timeout, force display content');
            if (loadingEl) loadingEl.style.display = 'none';
            if (mainContentEl) mainContentEl.style.display = 'block';
        }
    }, 10000);
    
    // Execute initialization immediately
    initPage();

    // Load all diagnostic data
    async function loadAllDiagnostics() {
        try {
            console.log('Starting to load factor diagnostics data...');
            
            // Check if DOM elements exist
            const loadingEl = document.getElementById('loading');
            const mainContentEl = document.getElementById('main-content');
            const errorEl = document.getElementById('error-message');
            
            if (!loadingEl || !mainContentEl) {
                console.error('DOM elements do not exist! loading:', !!loadingEl, 'main-content:', !!mainContentEl);
                return;
            }
            
            // Load all data in parallel (improve speed)
            // Use Promise.allSettled to ensure continuation even if some fail
            const promises = [
                loadRollingIC().catch(e => { console.error('Rolling IC failed:', e); return { error: e }; }),
                loadRollingICIR().catch(e => { console.error('Rolling ICIR failed:', e); return { error: e }; }),
                loadRollingTStat().catch(e => { console.error('Rolling t-stat failed:', e); return { error: e }; }),
                loadFactorList().catch(e => { console.error('Factor list failed:', e); return { error: e }; }),
                loadFactorClusters().catch(e => { console.error('Factor Clusters Analysis failed:', e); return { error: e }; }),
                loadCorrelationMatrix().catch(e => { console.error('Correlation matrix failed:', e); return { error: e }; }),
                loadRiskExposure().catch(e => { console.error('Risk exposure failed:', e); return { error: e }; })
            ];
            
            console.log('Waiting for all promises to complete...');
            const results = await Promise.allSettled(promises);
            console.log('Promise results:', results.map((r, i) => ({ index: i, status: r.status, value: r.status === 'fulfilled' ? 'ok' : r.reason })));
            
            console.log('All diagnostic data loaded (some may have failed)');
            
            // Show main content (even if some data failed to load)
            loadingEl.style.display = 'none';
            mainContentEl.style.display = 'block';
            console.log('Hide loading, show main content');
        } catch (error) {
            console.error('Failed to load diagnostic data:', error);
            console.error('Error stack:', error.stack);
            
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error-message');
            const errorTextEl = document.getElementById('error-text');
            
            if (loadingEl) loadingEl.style.display = 'none';
            if (errorEl) errorEl.style.display = 'block';
            if (errorTextEl) errorTextEl.textContent = 'Failed to load: ' + (error.message || 'Unknown error');
        }
    }

    // 1. Load Rolling IC
    async function loadRollingIC() {
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/rolling-ic` : '/api/factor-diagnostics/rolling-ic';
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.dates || data.dates.length === 0) {
                console.warn('Rolling IC data is empty:', data.error || 'No data');
                document.getElementById('rolling-ic-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                return;
            }
            
            const trace = {
                x: data.dates,
                y: data.ic_mean,
                type: 'scatter',
                mode: 'lines',
                name: 'Mean IC',
                line: { color: '#2E86AB', width: 2 }
            };
            
            const trace_upper = {
                x: data.dates,
                y: data.ic_upper,
                type: 'scatter',
                mode: 'lines',
                name: 'Upper Bound',
                line: { color: '#A23B72', width: 1, dash: 'dash' },
                fill: 'tonexty',
                fillcolor: 'rgba(162, 59, 114, 0.1)',
                showlegend: false
            };
            
            const trace_lower = {
                x: data.dates,
                y: data.ic_lower,
                type: 'scatter',
                mode: 'lines',
                name: 'Lower Bound',
                line: { color: '#A23B72', width: 1, dash: 'dash' },
                fill: 'tozeroy',
                fillcolor: 'rgba(162, 59, 114, 0.1)',
                showlegend: false
            };
            
            const chartEl = document.getElementById('rolling-ic-chart');
            if (chartEl) {
                Plotly.newPlot('rolling-ic-chart', [trace_lower, trace_upper, trace], {
                    title: 'Rolling IC',
                    xaxis: { title: 'Date' },
                    yaxis: { title: 'IC Value' },
                    hovermode: 'x unified',
                    template: 'plotly_white'
                });
                console.log('[Rolling IC] Chart rendered');
            } else {
                console.warn('[Rolling IC] Chart element does not exist');
            }
        } catch (error) {
            console.error('[Rolling IC] Failed to load:', error);
            const chartEl = document.getElementById('rolling-ic-chart');
            if (chartEl) {
                chartEl.innerHTML = '<p class="text-danger text-center py-5">Failed to load: ' + error.message + '</p>';
            }
            // Don't rethrow, let other charts continue loading
        }
    }

    // 2. Load Rolling ICIR
    async function loadRollingICIR() {
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/rolling-icir` : '/api/factor-diagnostics/rolling-icir';
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.dates || data.dates.length === 0) {
                console.warn('Rolling ICIR data is empty:', data.error || 'No data');
                document.getElementById('rolling-icir-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                return;
            }
            
            // Filter out NaN values for plotting
            const validData = [];
            const validDates = [];
            data.icir.forEach((value, index) => {
                if (value !== null && value !== undefined && !isNaN(value)) {
                    validData.push(value);
                    validDates.push(data.dates[index]);
                }
            });
            
            if (validData.length === 0) {
                console.warn('Rolling ICIR: No valid data after filtering NaN');
                document.getElementById('rolling-icir-chart').innerHTML = '<p class="text-muted text-center py-5">No valid ICIR data available</p>';
                return;
            }
            
            const trace = {
                x: validDates,
                y: validData,
                type: 'scatter',
                mode: 'lines',
                name: 'ICIR',
                line: { color: '#17a2b8', width: 2 }
            };
            
            const chartEl = document.getElementById('rolling-icir-chart');
            if (chartEl) {
                Plotly.newPlot('rolling-icir-chart', [trace], {
                    title: 'Rolling ICIR',
                    xaxis: { title: 'Date' },
                    yaxis: { title: 'ICIR Value' },
                    hovermode: 'x unified',
                    template: 'plotly_white'
                });
            }
        } catch (error) {
            console.error('Rolling ICIR Failed to load:', error);
            const chartEl = document.getElementById('rolling-icir-chart');
            if (chartEl) {
                chartEl.innerHTML = '<p class="text-danger text-center py-5">Failed to load: ' + (error.message || 'Unknown error') + '</p>';
            }
        }
    }

    // 3. Load Rolling t-stat
    async function loadRollingTStat() {
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/rolling-tstat` : '/api/factor-diagnostics/rolling-tstat';
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.dates || data.dates.length === 0) {
                console.warn('Rolling t-stat data is empty:', data.error || 'No data');
                document.getElementById('rolling-tstat-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                return;
            }
            
            const trace = {
                x: data.dates,
                y: data.tstat,
                type: 'scatter',
                mode: 'lines',
                name: 't-stat',
                line: { color: '#ffc107', width: 2 }
            };
            
            const shapes = [];
            if (data.dates.length > 0) {
                shapes.push({
                    type: 'line',
                    x0: data.dates[0],
                    x1: data.dates[data.dates.length - 1],
                    y0: 1.96,
                    y1: 1.96,
                    line: { color: 'red', width: 1, dash: 'dash' }
                }, {
                    type: 'line',
                    x0: data.dates[0],
                    x1: data.dates[data.dates.length - 1],
                    y0: -1.96,
                    y1: -1.96,
                    line: { color: 'red', width: 1, dash: 'dash' }
                });
            }
            
            Plotly.newPlot('rolling-tstat-chart', [trace], {
                title: 'Rolling t-stat',
                xaxis: { title: 'Date' },
                yaxis: { title: 't-stat Value' },
                hovermode: 'x unified',
                template: 'plotly_white',
                shapes: shapes
            });
        } catch (error) {
            console.error('Rolling t-stat Failed to load:', error);
            document.getElementById('rolling-tstat-chart').innerHTML = '<p class="text-danger text-center py-5">Failed to load</p>';
        }
    }

    // 4. Load Factor List
    async function loadFactorList() {
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/factors` : '/api/factor-diagnostics/factors';
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.factors || data.factors.length === 0) {
                console.warn('Factor list is empty:', data.error || 'No data');
                document.getElementById('factor-select').innerHTML = '<option value="">No factors available</option>';
                return;
            }
            
            const select = document.getElementById('factor-select');
            select.innerHTML = '<option value="">Please select a factor</option>';
            // Show all factors, no quantity limit
            data.factors.forEach(factor => {
                const option = document.createElement('option');
                option.value = factor;
                option.textContent = factor;
                select.appendChild(option);
            });
        } catch (error) {
            console.error('Factor list failed to load:', error);
            document.getElementById('factor-select').innerHTML = '<option value="">Failed to load</option>';
        }
    }

    // 5. Load Long-Short Performance
    async function loadLongShortPerformance() {
        const factor = document.getElementById('factor-select').value;
        if (!factor) {
            document.getElementById('long-short-chart').innerHTML = '<p class="text-muted text-center py-5">Please select a factor first</p>';
            return;
        }
        
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/long-short?factor=${encodeURIComponent(factor)}` : `/api/factor-diagnostics/long-short?factor=${encodeURIComponent(factor)}`;
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.dates || data.dates.length === 0) {
                console.warn('Long-Short Performance data is empty:', data.error || 'No data');
                document.getElementById('long-short-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                document.getElementById('long-short-table').innerHTML = '';
                return;
            }
        
        const traces = [
            {
                x: data.dates,
                y: data.long_returns,
                type: 'scatter',
                mode: 'lines',
                name: 'Long Portfolio',
                line: { color: '#28a745', width: 2 }
            },
            {
                x: data.dates,
                y: data.short_returns,
                type: 'scatter',
                mode: 'lines',
                name: 'Short Portfolio',
                line: { color: '#dc3545', width: 2 }
            },
            {
                x: data.dates,
                y: data.long_short_returns,
                type: 'scatter',
                mode: 'lines',
                name: 'Long-Short',
                line: { color: '#007bff', width: 2 }
            }
        ];
        
        Plotly.newPlot('long-short-chart', traces, {
            title: `Long-Short Portfolio Performance: ${factor}`,
            xaxis: { title: 'Date' },
            yaxis: { title: 'Cumulative Return' },
            hovermode: 'x unified',
            template: 'plotly_white'
        });
        
        // Show statistics table
        const table = `
            <table class="table table-striped">
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th>Long</th>
                        <th>Short</th>
                        <th>Long-Short</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Annual Return</td>
                        <td>${(data.stats.long_annual_return * 100).toFixed(2)}%</td>
                        <td>${(data.stats.short_annual_return * 100).toFixed(2)}%</td>
                        <td>${(data.stats.long_short_annual_return * 100).toFixed(2)}%</td>
                    </tr>
                    <tr>
                        <td>Sharpe Ratio</td>
                        <td>${data.stats.long_sharpe.toFixed(2)}</td>
                        <td>${data.stats.short_sharpe.toFixed(2)}</td>
                        <td>${data.stats.long_short_sharpe.toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td>Max Drawdown</td>
                        <td>${(data.stats.long_max_dd * 100).toFixed(2)}%</td>
                        <td>${(data.stats.short_max_dd * 100).toFixed(2)}%</td>
                        <td>${(data.stats.long_short_max_dd * 100).toFixed(2)}%</td>
                    </tr>
                </tbody>
            </table>
        `;
        document.getElementById('long-short-table').innerHTML = table;
        } catch (error) {
            console.error('Long-Short Performance Failed to load:', error);
            document.getElementById('long-short-chart').innerHTML = '<p class="text-danger text-center py-5">Failed to load</p>';
            document.getElementById('long-short-table').innerHTML = '';
        }
    }

    // 6. Load Factor Clusters Analysis
    async function loadFactorClusters() {
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/clusters` : '/api/factor-diagnostics/clusters';
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.clusters) {
                console.warn('Factor Clusters Analysis data is empty:', data.error || 'No data');
                document.getElementById('factor-cluster-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                document.getElementById('factor-cluster-table').innerHTML = '';
                document.getElementById('factor-cluster-explanation').innerHTML = '';
                return;
            }
        
        // Create scatter plot (IC vs ICIR)
        const traces = [];
        const categories = ['momentum', 'quality', 'volatility', 'value', 'size'];
        const colors = ['#2196F3', '#9C27B0', '#FF9800', '#4CAF50', '#E91E63'];
        
        categories.forEach((category, idx) => {
            const factors = data.clusters[category] || [];
            if (factors.length > 0) {
                const ic_values = factors.map(f => f.ic_mean || 0);
                const icir_values = factors.map(f => f.icir || 0);
                
                traces.push({
                    x: ic_values,
                    y: icir_values,
                    mode: 'markers',
                    type: 'scatter',
                    name: category.charAt(0).toUpperCase() + category.slice(1),
                    text: factors.map(f => f.name),
                    textposition: 'top center',
                    marker: { size: 12, color: colors[idx] },
                    hovertemplate: '<b>%{text}</b><br>Mean IC: %{x:.4f}<br>ICIR: %{y:.4f}<extra></extra>'
                });
            }
        });
        
        Plotly.newPlot('factor-cluster-chart', traces, {
            title: {
                text: 'Factor Clusters Analysis (IC vs ICIR)',
                font: { size: 18 }
            },
            xaxis: { 
                title: { text: 'Mean IC', font: { size: 14 } },
                titlefont: { size: 14 },
                tickfont: { size: 12 }
            },
            yaxis: { 
                title: { text: 'ICIR', font: { size: 14 } },
                titlefont: { size: 14 },
                tickfont: { size: 12 }
            },
            hovermode: 'closest',
            template: 'plotly_white',
            height: 600,
            margin: { l: 80, r: 50, t: 80, b: 80 },
            legend: {
                font: { size: 12 },
                x: 1.05,
                y: 1,
                xanchor: 'left',
                yanchor: 'top'
            }
        });
        
        // Show factor clusters table
        let tableHtml = '<table class="table table-striped"><thead><tr><th>Category</th><th>Factor</th><th>Mean IC</th><th>ICIR</th><th>t-stat</th></tr></thead><tbody>';
        categories.forEach(category => {
            const factors = data.clusters[category] || [];
            factors.forEach(factor => {
                tableHtml += `<tr>
                    <td><span class="factor-category ${category}">${category}</span></td>
                    <td>${factor.name}</td>
                    <td>${(factor.ic_mean || 0).toFixed(4)}</td>
                    <td>${(factor.icir || 0).toFixed(4)}</td>
                    <td>${(factor.tstat || 0).toFixed(2)}</td>
                </tr>`;
            });
        });
        tableHtml += '</tbody></table>';
        document.getElementById('factor-cluster-table').innerHTML = tableHtml;
        
        // Build explanation section dynamically based on existing categories
        const categoryDescriptions = {
            'momentum': {
                icon: 'fa-chart-line',
                emoji: 'üìà',
                title: 'Momentum Factors',
                class: 'text-primary',
                description: 'Momentum factors capture the tendency of stock prices to continue their trends. Factors include past N-day returns, relative strength indicators, and price trend patterns. <strong>High IC values</strong> indicate that stocks with strong past performance are more likely to continue outperforming. These factors work best when market trends are persistent.'
            },
            'quality': {
                icon: 'fa-gem',
                emoji: 'üíé',
                title: 'Quality Factors',
                class: 'text-purple',
                description: 'Quality factors measure a company\'s financial health and profitability, including ROE, ROA, profit margins, debt ratios, and earnings stability. High-quality companies typically deliver better long-term returns with lower volatility. <strong>Consistently positive IC</strong> suggests that fundamental quality is rewarded over time, suitable for long-term holding strategies.'
            },
            'volatility': {
                icon: 'fa-wave-square',
                emoji: 'üìä',
                title: 'Volatility Factors',
                class: 'text-warning',
                description: 'Volatility factors reflect price uncertainty and risk. Low volatility stocks tend to have lower risk but may miss high-return opportunities. These include historical volatility, downside volatility, and risk-adjusted returns. <strong>Negative IC</strong> may indicate market preference for low-volatility stocks (risk-aversion behavior).'
            },
            'value': {
                icon: 'fa-dollar-sign',
                emoji: 'üí∞',
                title: 'Value Factors',
                class: 'text-success',
                description: 'Value factors identify undervalued stocks using valuation metrics like P/E, P/B, EV/EBITDA, and price-to-sales ratios. Value investing seeks stocks trading below their intrinsic value. <strong>Positive IC</strong> suggests mean reversion exists - cheap stocks tend to appreciate as the market corrects mispricing over time.'
            },
            'size': {
                icon: 'fa-building',
                emoji: 'üè¢',
                title: 'Size Factors',
                class: 'text-danger',
                description: 'Size factors measure company market capitalization. Small-cap stocks typically exhibit higher volatility and potential returns due to the small-cap premium effect observed in long-term data. However, <strong>size effects vary with market cycles</strong> - large caps may outperform during risk-off periods, while small caps excel during risk-on periods.'
            }
        };
        
        // Find which categories actually exist in the data
        const existingCategories = categories.filter(cat => {
            const factors = data.clusters[cat] || [];
            return factors.length > 0;
        });
        
        // Build explanation HTML only for existing categories
        let leftColumnHtml = '';
        let rightColumnHtml = '';
        
        existingCategories.forEach((category, index) => {
            const desc = categoryDescriptions[category];
            if (!desc) return; // Skip if description not defined
            
            const categoryHtml = `
                <h6 class="${desc.class}"><i class="fas ${desc.icon} me-2"></i>${desc.emoji} ${desc.title}</h6>
                <p class="small mb-3">${desc.description}</p>
            `;
            
            // Distribute categories between left and right columns
            if (index < Math.ceil(existingCategories.length / 2)) {
                leftColumnHtml += categoryHtml;
            } else {
                rightColumnHtml += categoryHtml;
            }
        });
        
        // Add chart interpretation guide to the right column
        rightColumnHtml += `
            <h6><i class="fas fa-chart-area me-2"></i>Chart Interpretation Guide</h6>
            <ul class="small">
                <li><strong>X-axis (Mean IC)</strong>: Correlation between factor and future returns. 
                    Absolute value indicates predictive power; higher = stronger signal.</li>
                <li><strong>Y-axis (ICIR)</strong>: Information Ratio = IC mean / IC std, measuring 
                    factor stability over time. Higher ICIR = more consistent performance.</li>
                <li><strong>Top-right quadrant</strong>: Ideal region with both high IC and high ICIR, 
                    indicating effective and stable factors worth including in strategies.</li>
                <li><strong>t-stat</strong>: Statistical significance. |t-stat| > 2 typically indicates 
                    significant factor performance (95% confidence level).</li>
            </ul>
        `;
        
        // Build final explanation HTML
        const explanationHtml = `
            <div class="mt-4 p-4 bg-light rounded">
                <h5><i class="fas fa-info-circle me-2"></i>Factor Cluster Analysis Interpretation</h5>
                <div class="row">
                    <div class="col-md-6">
                        ${leftColumnHtml}
                    </div>
                    <div class="col-md-6">
                        ${rightColumnHtml}
                    </div>
                </div>
            </div>
        `;
        document.getElementById('factor-cluster-explanation').innerHTML = explanationHtml;
        } catch (error) {
            console.error('Factor Clusters AnalysisFailed to load:', error);
            document.getElementById('factor-cluster-chart').innerHTML = '<p class="text-danger text-center py-5">Failed to load</p>';
            document.getElementById('factor-cluster-table').innerHTML = '';
            document.getElementById('factor-cluster-explanation').innerHTML = '';
        }
    }

    // 7. Load Correlation Matrix
    async function loadCorrelationMatrix() {
        try {
            const method = document.getElementById('correlation-method').value;
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/correlation?method=${method}` : `/api/factor-diagnostics/correlation?method=${method}`;
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.factors || data.factors.length === 0) {
                console.warn('Correlation matrix data is empty:', data.error || 'No data');
                document.getElementById('correlation-matrix-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                return;
            }
        
        const trace = {
            z: data.correlation_matrix,
            x: data.factors,
            y: data.factors,
            type: 'heatmap',
            colorscale: 'RdBu',
            zmid: 0,
            colorbar: { title: 'Correlation' }
        };
        
        Plotly.newPlot('correlation-matrix-chart', [trace], {
            title: 'Factor Correlation Matrix',
            template: 'plotly_white',
            width: 800,
            height: 600
        });
        } catch (error) {
            console.error('Correlation matrix failed to load:', error);
            document.getElementById('correlation-matrix-chart').innerHTML = '<p class="text-danger text-center py-5">Failed to load</p>';
        }
    }

    // 8. Load Risk Exposure
    async function loadRiskExposure() {
        try {
            let date = document.getElementById('exposure-date').value;
            if (!date) {
                // If no date selected, use latest date
                try {
                    const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/latest-date` : '/api/factor-diagnostics/latest-date';
                    const response = await fetch(url);
                    const data = await response.json();
                    if (data.date && !data.error) {
                        document.getElementById('exposure-date').value = data.date;
                        date = data.date;
                    } else {
                        const chartEl = document.getElementById('risk-exposure-chart');
                        if (chartEl) {
                            chartEl.innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                        }
                        document.getElementById('risk-exposure-table').innerHTML = '';
                        document.getElementById('risk-exposure-explanation').innerHTML = '';
                        return; // Cannot get date, skip loading
                    }
                } catch (e) {
                    console.error('Failed to get latest date:', e);
                    const chartEl = document.getElementById('risk-exposure-chart');
                    if (chartEl) {
                        chartEl.innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                    }
                    document.getElementById('risk-exposure-table').innerHTML = '';
                    document.getElementById('risk-exposure-explanation').innerHTML = '';
                    return;
                }
            }
            
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/risk-exposure?date=${date}` : `/api/factor-diagnostics/risk-exposure?date=${date}`;
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.factors || data.factors.length === 0) {
                console.warn('Risk exposure data is empty:', data.error || 'No data');
                document.getElementById('risk-exposure-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                document.getElementById('risk-exposure-table').innerHTML = '';
                document.getElementById('risk-exposure-explanation').innerHTML = '';
                return;
            }
            
            const chartEl = document.getElementById('risk-exposure-chart');
            if (!chartEl) {
                console.error('Risk exposure chart element not found');
                return;
            }
            
            // Clear any existing error messages
            chartEl.innerHTML = '';
            
            const trace = {
                x: data.factors,
                y: data.exposures,
                type: 'bar',
                marker: { color: data.exposures.map(e => e > 0 ? '#28a745' : '#dc3545') }
            };
            
            Plotly.newPlot('risk-exposure-chart', [trace], {
                title: `Risk Exposure (Barra-style) - ${date}`,
                xaxis: { title: 'Factor' },
                yaxis: { title: 'Exposure' },
                template: 'plotly_white'
            });
            
            // Show risk exposure table
            let tableHtml = '<table class="table table-striped"><thead><tr><th>Style Factor</th><th>Exposure</th><th>Risk Contribution</th></tr></thead><tbody>';
            data.factors.forEach((factor, idx) => {
                // Risk contribution is already in percentage from backend (0-100), no need to multiply by 100
                const riskContrib = data.risk_contributions[idx];
                tableHtml += `<tr>
                    <td><strong>${factor}</strong></td>
                    <td>${data.exposures[idx].toFixed(4)}</td>
                    <td>${typeof riskContrib === 'number' ? riskContrib.toFixed(2) : '0.00'}%</td>
                </tr>`;
            });
            // Add specific risk row if available
            if (data.specific_risk_contribution !== undefined && data.specific_risk_contribution !== null) {
                tableHtml += `<tr class="table-info">
                    <td><strong>Specific Risk (Idiosyncratic)</strong></td>
                    <td>-</td>
                    <td>${typeof data.specific_risk_contribution === 'number' ? data.specific_risk_contribution.toFixed(2) : '0.00'}%</td>
                </tr>`;
            }
            tableHtml += '</tbody></table>';
            document.getElementById('risk-exposure-table').innerHTML = tableHtml;
            
            // Add/update explanation section (replace existing content to avoid duplicates)
            const explanationHtml = `
                <div class="mt-4 p-4 bg-light rounded">
                    <h6><i class="fas fa-info-circle me-2"></i>Multi-Factor Risk Exposure (Barra-style) Interpretation</h6>
                    <div class="row">
                        <div class="col-md-12">
                            <h6><i class="fas fa-chart-bar me-2"></i>What is Barra-Style Risk Exposure?</h6>
                            <p class="small mb-3">
                                This analysis uses a <strong>Barra-style multi-factor risk model</strong> to decompose portfolio risk. 
                                Unlike raw factor analysis, this model:
                            </p>
                            <ul class="small mb-3">
                                <li><strong>Groups raw factors</strong> into economically interpretable style buckets (Price/Level, Trend, Momentum, Volatility, Liquidity, Quality/Stability, Custom)</li>
                                <li><strong>Excludes Alpha factors</strong> from risk modeling (Alpha factors contribute to expected returns and specific risk, not systematic risk)</li>
                                <li><strong>Applies PCA</strong> within each style bucket to extract the dominant factor, reducing multicollinearity</li>
                                <li><strong>Orthogonalizes style factors</strong> to ensure independent risk sources</li>
                                <li><strong>Separates systematic risk</strong> (factor risk) from <strong>specific risk</strong> (idiosyncratic risk)</li>
                            </ul>
                            <p class="small mb-3">
                                The displayed factors are <strong>style-level factors</strong>, not individual raw factors, providing a clean and interpretable risk decomposition.
                            </p>
                            
                            <h6><i class="fas fa-arrow-up me-2"></i>Positive Exposure</h6>
                            <p class="small mb-3">
                                A <strong>positive exposure</strong> (green bars) indicates the portfolio is 
                                overweight in that factor. For example, a positive momentum exposure means the 
                                portfolio holds more high-momentum stocks than the benchmark. This can be 
                                intentional if the strategy aims to capture momentum effects.
                            </p>
                            
                            <h6><i class="fas fa-arrow-down me-2"></i>Negative Exposure</h6>
                            <p class="small mb-3">
                                A <strong>negative exposure</strong> (red bars) indicates the portfolio is 
                                underweight in that factor. For example, a negative value exposure means the 
                                portfolio holds fewer value stocks than the benchmark, preferring growth stocks instead.
                            </p>
                            
                            <h6><i class="fas fa-percentage me-2"></i>Risk Contribution</h6>
                            <p class="small mb-3">
                                <strong>Risk Contribution (%)</strong> shows what percentage of the portfolio's 
                                total risk comes from each factor. Factors with higher risk contributions should 
                                be closely monitored, as they drive most of the portfolio's volatility. A 
                                well-diversified portfolio typically has risk contributions spread across 
                                multiple factors rather than concentrated in one or two.
                            </p>
                            <h6><i class="fas fa-percentage me-2"></i>Risk Contribution Interpretation</h6>
                            <p class="small mb-3">
                                <strong>Risk Contribution (%)</strong> shows what percentage of the portfolio's total risk 
                                comes from each style factor. The contributions sum to 100% (or close to 100% if specific risk 
                                is included separately).
                            </p>
                            <p class="small mb-3">
                                <strong>Style Factor Distribution:</strong> In a well-balanced Barra model, risk is typically 
                                distributed across multiple style factors. The concentration of risk in a few factors (e.g., 
                                Liquidity, Momentum) indicates the portfolio's sensitivity to those particular risk dimensions.
                            </p>
                            <p class="small mb-3">
                                <strong>Specific Risk:</strong> This represents idiosyncratic (stock-specific) risk that cannot 
                                be explained by systematic style factors. It captures company-specific events, earnings surprises, 
                                and other non-systematic risks. A well-diversified portfolio typically has lower specific risk 
                                contribution.
                            </p>
                            
                            <h6><i class="fas fa-lightbulb me-2"></i>How to Use This Analysis</h6>
                            <ul class="small">
                                <li><strong>Identify Concentration Risk:</strong> If one factor accounts for >50% 
                                    of risk contribution, consider diversifying to reduce concentration.</li>
                                <li><strong>Monitor Factor Drift:</strong> Track exposure changes over time to 
                                    ensure the portfolio stays aligned with the intended strategy.</li>
                                <li><strong>Factor Timing:</strong> Adjust exposures based on market conditions 
                                    (e.g., increase quality exposure during market stress).</li>
                                <li><strong>Rebalancing Signal:</strong> Large exposure changes may indicate 
                                    the need for portfolio rebalancing to maintain target factor weights.</li>
                            </ul>
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('risk-exposure-explanation').innerHTML = explanationHtml;
        } catch (error) {
            console.error('Risk exposure failed to load:', error);
            document.getElementById('risk-exposure-chart').innerHTML = '<p class="text-danger text-center py-5">Failed to load</p>';
            document.getElementById('risk-exposure-table').innerHTML = '';
            document.getElementById('risk-exposure-explanation').innerHTML = '';
        }
    }
</script>
{% endblock %}

