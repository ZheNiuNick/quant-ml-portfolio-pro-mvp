{% extends "base.html" %}

{% block title %}Factor Diagnostics- Quantitative Trading Strategy Dashboard{% endblock %}

{% block extra_head %}
<style>
    .diagnostic-card {
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .metric-value {
        font-size: 1.5em;
        font-weight: bold;
    }
    .metric-label {
        color: #666;
        font-size: 0.9em;
    }
    .chart-container {
        height: 400px;
        margin-bottom: 20px;
    }
    #factor-cluster-chart {
        height: 600px !important;
    }
    .factor-category {
        padding: 10px;
        margin: 5px;
        border-radius: 5px;
        display: inline-block;
    }
    .momentum { background-color: #e3f2fd; }
    .quality { background-color: #f3e5f5; }
    .volatility { background-color: #fff3e0; }
    .value { background-color: #e8f5e9; }
    .size { background-color: #fce4ec; }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row mb-4">
        <div class="col-12">
            <h2 class="mb-0"><i class="fas fa-microscope me-2"></i>Factor Diagnostics</h2>
            <p class="text-muted">Factor evaluation, IC analysis, risk exposure and correlation analysis</p>
        </div>
    </div>

    <!-- Loading Status -->
    <div id="loading" class="text-center py-5">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-3">Loading factor diagnostics data...</p>
    </div>

    <!-- Error Message -->
    <div id="error-message" class="alert alert-danger" style="display: none;">
        <i class="fas fa-exclamation-triangle me-2"></i>
        <span id="error-text"></span>
    </div>

    <!-- Main Content -->
    <div id="main-content" style="display: none;">
        <!-- 1. Rolling IC Curve -->
        <div class="card diagnostic-card">
            <div class="card-header bg-primary text-white">
                <h5 class="mb-0"><i class="fas fa-chart-line me-2"></i>Rolling IC (60D) - Single Factor Analysis</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="rolling-factor-select" class="form-label">Select Factor:</label>
                    <select id="rolling-factor-select" class="form-select" onchange="loadRollingMetrics()">
                        <option value="">Loading factors...</option>
                    </select>
                </div>
                <p class="text-muted small mb-2">
                    <i class="fas fa-info-circle me-1"></i>
                    Rolling statistics begin once 60 trading days of data are available.
                </p>
                <div id="rolling-ic-chart" class="chart-container" style="height: 450px; width: 100%;"></div>
            </div>
        </div>

        <!-- 2. Rolling ICIR and t-stat -->
        <div class="row mt-3">
            <div class="col-md-6">
                <div class="card diagnostic-card">
                    <div class="card-header bg-info text-white">
                        <h5 class="mb-0"><i class="fas fa-chart-area me-2"></i>Rolling ICIR (60D)</h5>
                    </div>
                    <div class="card-body">
                        <p class="text-muted small mb-3">
                            <i class="fas fa-info-circle me-1"></i>
                            ICIR = mean(IC_60d) / std(IC_60d)
                        </p>
                        <div id="rolling-icir-chart" class="chart-container"></div>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card diagnostic-card">
                    <div class="card-header bg-warning text-dark">
                        <h5 class="mb-0"><i class="fas fa-chart-bar me-2"></i>Rolling t-stat (60D)</h5>
                    </div>
                    <div class="card-body">
                        <p class="text-muted small mb-3">
                            <i class="fas fa-info-circle me-1"></i>
                            t-stat = mean(IC_60d) / std(IC_60d) × √N
                        </p>
                        <div id="rolling-tstat-chart" class="chart-container"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 3. Long-Short Portfolio Performance -->
        <div class="card diagnostic-card">
            <div class="card-header bg-success text-white">
                <h5 class="mb-0"><i class="fas fa-exchange-alt me-2"></i>Long-Short Portfolio Performance (by Factor)</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="factor-select" class="form-label">Select Factor:</label>
                    <select id="factor-select" class="form-select" onchange="loadLongShortPerformance()">
                        <option value="">Loading...</option>
                    </select>
                </div>
                <div class="alert alert-info small mb-3" role="alert">
                    <strong>Definition:</strong><br>
                    • <strong>Long Portfolio</strong> = Top quintile (20%) stocks with highest factor scores<br>
                    • <strong>Short Portfolio</strong> = Bottom quintile (20%) stocks with lowest factor scores<br>
                    • <strong>Long-Short Return</strong> = long_return - short_return (the difference, not cumulative subtraction)<br>
                    • <strong>Note:</strong> If Short portfolio outperforms Long portfolio (Long-Short is negative), this indicates the factor is <strong>negatively predictive</strong>. In such cases, reverse the factor sign for trading.
                </div>
                <div id="long-short-chart" class="chart-container"></div>
                <div id="long-short-table" class="mt-3"></div>
            </div>
        </div>

        <!-- 4. Factor Correlation Matrix -->
        <section id="factor-correlation-section" class="card diagnostic-card">
            <div class="card-header bg-dark text-white">
                <h5 class="mb-0"><i class="fas fa-th me-2"></i>Factor Correlation Matrix</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="correlation-top-k" class="form-label">Factor Subset:</label>
                    <select id="correlation-top-k" class="form-select" style="max-width: 300px;" onchange="loadCorrelationMatrix()">
                        <option value="20">Top 20 Factors</option>
                        <option value="50" selected>Top 50 Factors</option>
                        <option value="100">Top 100 Factors</option>
                    </select>
                    <small class="form-text text-muted">Using Pearson correlation method</small>
                </div>
                <div id="factor-correlation-plot-wrapper" style="position: relative; width: 100%; min-height: 700px; overflow: visible;">
                    <div id="correlation-matrix-chart" class="chart-container" style="position: relative; width: 100%;"></div>
                </div>
            </div>
        </section>
        
        <!-- Structural spacer to prevent overlap -->
        <div class="section-spacer" style="display: block; height: 64px; width: 100%;"></div>

        <!-- 6. Multi-Factor Risk Exposure (Barra-style) -->
        <div class="card diagnostic-card">
            <div class="card-header bg-danger text-white">
                <h5 class="mb-0"><i class="fas fa-shield-alt me-2"></i>Multi-Factor Risk Exposure (Barra-style)</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="exposure-date" class="form-label">Select Date:</label>
                    <input type="date" id="exposure-date" class="form-control" onchange="loadRiskExposure()">
                </div>
                <div id="risk-exposure-chart" class="chart-container"></div>
                <div id="risk-exposure-table" class="mt-3"></div>
                <div id="risk-exposure-explanation"></div>
            </div>
        </div>

        <!-- 7. Factor Distribution by Barra Style (IC vs ICIR) -->
        <div class="card diagnostic-card">
            <div class="card-header bg-secondary text-white">
                <h5 class="mb-0"><i class="fas fa-layer-group me-2"></i>Factor Distribution by Barra Style (IC vs ICIR)</h5>
            </div>
            <div class="card-body">
                <div class="alert alert-info small mb-3" role="alert">
                    <strong>Note:</strong> This is NOT machine learning clustering. Factors are grouped by Barra-style economic definitions used in the Multi-Factor Risk Exposure model. The purpose is to evaluate factor quality and stability within each risk style bucket.
                </div>
                <div id="factor-cluster-chart" class="chart-container"></div>
                <div id="factor-cluster-table" class="mt-3"></div>
                <div id="factor-cluster-explanation"></div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    // API_BASE_URL is already declared in base.html, use it directly here

    // Initialize on page load
    function initPage() {
        console.log('Initializing page, DOM Status:', document.readyState);
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                console.log('DOMContentLoaded event triggered');
                setTimeout(() => loadAllDiagnostics(), 100);
            });
        } else {
            console.log('DOM ready, execute directly');
            setTimeout(() => loadAllDiagnostics(), 100);
        }
    }
    
    // Add timeout protection: if still loading after 10 seconds, force display content
    setTimeout(() => {
        const loadingEl = document.getElementById('loading');
        const mainContentEl = document.getElementById('main-content');
        if (loadingEl && loadingEl.style.display !== 'none') {
            console.warn('Loading timeout, force display content');
            if (loadingEl) loadingEl.style.display = 'none';
            if (mainContentEl) mainContentEl.style.display = 'block';
        }
    }, 10000);
    
    // Execute initialization immediately
    initPage();

    // Load all diagnostic data
    async function loadAllDiagnostics() {
        try {
            console.log('Starting to load factor diagnostics data...');
            
            // Check if DOM elements exist
            const loadingEl = document.getElementById('loading');
            const mainContentEl = document.getElementById('main-content');
            const errorEl = document.getElementById('error-message');
            
            if (!loadingEl || !mainContentEl) {
                console.error('DOM elements do not exist! loading:', !!loadingEl, 'main-content:', !!mainContentEl);
                return;
            }
            
            // First, load factor list for Rolling metrics selector
            await loadRollingFactorList();
            
            // Load all data in parallel (improve speed)
            // Use Promise.allSettled to ensure continuation even if some fail
            // Note: Rolling metrics are loaded after factor selection
            const promises = [
                loadFactorList().catch(e => { console.error('Factor list failed:', e); return { error: e }; }),
                loadFactorClusters().catch(e => { console.error('Factor Clusters Analysis failed:', e); return { error: e }; }),
                loadCorrelationMatrix().catch(e => { console.error('Correlation matrix failed:', e); return { error: e }; }),
                loadRiskExposure().catch(e => { console.error('Risk exposure failed:', e); return { error: e }; })
            ];
            
            console.log('Waiting for all promises to complete...');
            const results = await Promise.allSettled(promises);
            console.log('Promise results:', results.map((r, i) => ({ index: i, status: r.status, value: r.status === 'fulfilled' ? 'ok' : r.reason })));
            
            console.log('All diagnostic data loaded (some may have failed)');
            
            // Show main content (even if some data failed to load)
            loadingEl.style.display = 'none';
            mainContentEl.style.display = 'block';
            console.log('Hide loading, show main content');
            
            // Add window resize listener for Rolling IC chart
            const rollingIcChart = document.getElementById('rolling-ic-chart');
            if (rollingIcChart) {
                window.addEventListener('resize', () => {
                    if (rollingIcChart.data && rollingIcChart.data.length > 0) {
                        Plotly.Plots.resize(rollingIcChart);
                    }
                });
            }
        } catch (error) {
            console.error('Failed to load diagnostic data:', error);
            console.error('Error stack:', error.stack);
            
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error-message');
            const errorTextEl = document.getElementById('error-text');
            
            if (loadingEl) loadingEl.style.display = 'none';
            if (errorEl) errorEl.style.display = 'block';
            if (errorTextEl) errorTextEl.textContent = 'Failed to load: ' + (error.message || 'Unknown error');
        }
    }

    // Shared factor selector for Rolling metrics
    let selectedRollingFactor = '';
    
    // Load factor list for Rolling metrics selector
    async function loadRollingFactorList() {
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/factors` : '/api/factor-diagnostics/factors';
            const response = await fetch(url);
            const data = await response.json();
            
            const selectEl = document.getElementById('rolling-factor-select');
            if (!selectEl) return;
            
            if (data.error || !data.factors || data.factors.length === 0) {
                selectEl.innerHTML = '<option value="">No factors available</option>';
                return;
            }
            
            // Use all factors (including Alpha, CUSTOM, and TALIB factors)
            const factorsToUse = data.factors;
            
            selectEl.innerHTML = '<option value="">Select a factor...</option>';
            factorsToUse.forEach(factor => {
                const option = document.createElement('option');
                option.value = factor;
                option.textContent = factor;
                selectEl.appendChild(option);
            });
            
            // Set default to first alpha factor
            if (factorsToUse.length > 0) {
                selectedRollingFactor = factorsToUse[0];
                selectEl.value = selectedRollingFactor;
                loadRollingMetrics();
            }
        } catch (error) {
            console.error('[Rolling Factor List] Failed to load:', error);
        }
    }
    
    // Load all rolling metrics (IC, ICIR, t-stat) for selected factor
    function loadRollingMetrics() {
        const selectEl = document.getElementById('rolling-factor-select');
        if (!selectEl) return;
        
        selectedRollingFactor = selectEl.value;
        if (!selectedRollingFactor) {
            // Clear all charts
            document.getElementById('rolling-ic-chart').innerHTML = '<p class="text-muted text-center py-5">Please select a factor</p>';
            document.getElementById('rolling-icir-chart').innerHTML = '<p class="text-muted text-center py-5">Please select a factor</p>';
            document.getElementById('rolling-tstat-chart').innerHTML = '<p class="text-muted text-center py-5">Please select a factor</p>';
            return;
        }
        
        loadRollingIC();
        loadRollingICIR();
        loadRollingTStat();
    }

    // 1. Load Rolling IC
    async function loadRollingIC() {
        if (!selectedRollingFactor) return;
        
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/rolling-ic?factor=${encodeURIComponent(selectedRollingFactor)}` : `/api/factor-diagnostics/rolling-ic?factor=${encodeURIComponent(selectedRollingFactor)}`;
            console.log('[Rolling IC] Requesting URL:', url);
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.dates || data.dates.length === 0) {
                console.warn('Rolling IC data is empty:', data.error || 'No data');
                document.getElementById('rolling-ic-chart').innerHTML = `<p class="text-muted text-center py-5">${data.error || 'No data available'}</p>`;
                return;
            }
            
            // Filter out null/NaN values for plotting
            const validIcMean = [];
            const validIcUpper = [];
            const validIcLower = [];
            const validDates = [];
            data.rolling_ic.forEach((value, index) => {
                if (value !== null && value !== undefined && !isNaN(value)) {
                    validIcMean.push(value);
                    validIcUpper.push(data.ic_upper[index]);
                    validIcLower.push(data.ic_lower[index]);
                    validDates.push(data.dates[index]);
                }
            });
            
            if (validIcMean.length === 0) {
                const daysAvailable = data.dates ? data.dates.length : 0;
                const message = daysAvailable < 60 
                    ? `Insufficient data: ${daysAvailable} trading days available. Rolling IC requires at least 60 trading days.`
                    : 'No valid Rolling IC data available';
                document.getElementById('rolling-ic-chart').innerHTML = 
                    `<div class="text-center py-5">
                        <p class="text-muted mb-2"><i class="fas fa-info-circle me-1"></i>Rolling statistics begin once 60 trading days of data are available.</p>
                        <p class="text-muted"><i class="fas fa-exclamation-triangle me-1"></i>${message}</p>
                    </div>`;
                return;
            }
            
            const trace = {
                x: validDates,
                y: validIcMean,
                type: 'scatter',
                mode: 'lines',
                name: `Rolling IC (${data.factor || selectedRollingFactor})`,
                line: { color: '#2E86AB', width: 2 }
            };
            
            const trace_upper = {
                x: validDates,
                y: validIcUpper,
                type: 'scatter',
                mode: 'lines',
                name: 'Upper Bound',
                line: { color: '#A23B72', width: 1, dash: 'dash' },
                fill: 'tonexty',
                fillcolor: 'rgba(162, 59, 114, 0.1)',
                showlegend: false
            };
            
            const trace_lower = {
                x: validDates,
                y: validIcLower,
                type: 'scatter',
                mode: 'lines',
                name: 'Lower Bound',
                line: { color: '#A23B72', width: 1, dash: 'dash' },
                fill: 'tozeroy',
                fillcolor: 'rgba(162, 59, 114, 0.1)',
                showlegend: false
            };
            
            const chartEl = document.getElementById('rolling-ic-chart');
            if (!chartEl) {
                console.warn('[Rolling IC] Chart element does not exist');
                return;
            }
            
            // Check if chart already exists (use Plotly.react for updates)
            const chartExists = chartEl.data && chartEl.data.length > 0;
            const plotFn = chartExists ? Plotly.react : Plotly.newPlot;
            
            // Delay initial render until layout is stable
            const renderChart = () => {
                plotFn('rolling-ic-chart', [trace_lower, trace_upper, trace], {
                    title: `Rolling IC (60D) - ${data.factor || selectedRollingFactor}`,
                    xaxis: { title: 'Date' },
                    yaxis: { title: 'IC Value' },
                    hovermode: 'x unified',
                    template: 'plotly_white',
                    height: 450
                }).then(() => {
                    // Force resize after render to ensure proper dimensions
                    Plotly.Plots.resize(chartEl);
                    console.log('[Rolling IC] Chart rendered and resized');
                }).catch(error => {
                    console.error('[Rolling IC] Plotly render error:', error);
                });
            };
            
            if (chartExists) {
                // For factor changes, render immediately
                renderChart();
            } else {
                // For initial render, wait for layout to be stable
                requestAnimationFrame(() => {
                    setTimeout(() => {
                        renderChart();
                    }, 0);
                });
            }
        } catch (error) {
            console.error('[Rolling IC] Failed to load:', error);
            const chartEl = document.getElementById('rolling-ic-chart');
            if (chartEl) {
                chartEl.innerHTML = '<p class="text-danger text-center py-5">Failed to load: ' + error.message + '</p>';
            }
        }
    }

    // 2. Load Rolling ICIR
    async function loadRollingICIR() {
        if (!selectedRollingFactor) return;
        
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/rolling-icir?factor=${encodeURIComponent(selectedRollingFactor)}` : `/api/factor-diagnostics/rolling-icir?factor=${encodeURIComponent(selectedRollingFactor)}`;
            console.log('[Rolling ICIR] Requesting URL:', url);
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.dates || data.dates.length === 0) {
                console.warn('Rolling ICIR data is empty:', data.error || 'No data');
                document.getElementById('rolling-icir-chart').innerHTML = `<p class="text-muted text-center py-5">${data.error || 'No data available'}</p>`;
                return;
            }
            
            // Filter out NaN values for plotting
            const validData = [];
            const validDates = [];
            data.rolling_icir.forEach((value, index) => {
                if (value !== null && value !== undefined && !isNaN(value)) {
                    validData.push(value);
                    validDates.push(data.dates[index]);
                }
            });
            
            if (validData.length === 0) {
                console.warn('Rolling ICIR: No valid data after filtering NaN');
                const daysAvailable = data.dates ? data.dates.length : 0;
                const message = daysAvailable < 60 
                    ? `Insufficient data: ${daysAvailable} trading days available. Rolling ICIR requires at least 60 trading days.`
                    : 'No valid ICIR data available';
                document.getElementById('rolling-icir-chart').innerHTML = 
                    `<div class="text-center py-5">
                        <p class="text-muted mb-2"><i class="fas fa-info-circle me-1"></i>ICIR = mean(IC_60d) / std(IC_60d)</p>
                        <p class="text-muted"><i class="fas fa-exclamation-triangle me-1"></i>${message}</p>
                    </div>`;
                return;
            }
            
            const trace = {
                x: validDates,
                y: validData,
                type: 'scatter',
                mode: 'lines',
                name: `Rolling ICIR (${data.factor || selectedRollingFactor})`,
                line: { color: '#17a2b8', width: 2 }
            };
            
            const chartEl = document.getElementById('rolling-icir-chart');
            if (chartEl) {
            Plotly.newPlot('rolling-icir-chart', [trace], {
                    title: `Rolling ICIR (60D) - ${data.factor || selectedRollingFactor}`,
                xaxis: { title: 'Date' },
                yaxis: { title: 'ICIR Value' },
                hovermode: 'x unified',
                template: 'plotly_white'
            });
            }
        } catch (error) {
            console.error('Rolling ICIR Failed to load:', error);
            const chartEl = document.getElementById('rolling-icir-chart');
            if (chartEl) {
                chartEl.innerHTML = '<p class="text-danger text-center py-5">Failed to load: ' + (error.message || 'Unknown error') + '</p>';
            }
        }
    }

    // 3. Load Rolling t-stat
    async function loadRollingTStat() {
        if (!selectedRollingFactor) return;
        
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/rolling-tstat?factor=${encodeURIComponent(selectedRollingFactor)}` : `/api/factor-diagnostics/rolling-tstat?factor=${encodeURIComponent(selectedRollingFactor)}`;
            console.log('[Rolling t-stat] Requesting URL:', url);
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.dates || data.dates.length === 0) {
                console.warn('Rolling t-stat data is empty:', data.error || 'No data');
                document.getElementById('rolling-tstat-chart').innerHTML = `<p class="text-muted text-center py-5">${data.error || 'No data available'}</p>`;
                return;
            }
            
            // Filter out null/NaN values for plotting
            const validData = [];
            const validDates = [];
            data.rolling_tstat.forEach((value, index) => {
                if (value !== null && value !== undefined && !isNaN(value)) {
                    validData.push(value);
                    validDates.push(data.dates[index]);
                }
            });
            
            if (validData.length === 0) {
                console.warn('Rolling t-stat: No valid data after filtering NaN');
                const daysAvailable = data.dates ? data.dates.length : 0;
                const message = daysAvailable < 60 
                    ? `Insufficient data: ${daysAvailable} trading days available. Rolling t-stat requires at least 60 trading days.`
                    : 'No valid t-stat data available';
                document.getElementById('rolling-tstat-chart').innerHTML = 
                    `<div class="text-center py-5">
                        <p class="text-muted mb-2"><i class="fas fa-info-circle me-1"></i>t-stat = mean(IC_60d) / std(IC_60d) × √N</p>
                        <p class="text-muted"><i class="fas fa-exclamation-triangle me-1"></i>${message}</p>
                    </div>`;
                return;
            }
            
            const trace = {
                x: validDates,
                y: validData,
                type: 'scatter',
                mode: 'lines',
                name: `Rolling t-stat (${data.factor || selectedRollingFactor})`,
                line: { color: '#ffc107', width: 2 }
            };
            
            const shapes = [];
            if (validDates.length > 0) {
                shapes.push({
                    type: 'line',
                    x0: validDates[0],
                    x1: validDates[validDates.length - 1],
                    y0: 1.96,
                    y1: 1.96,
                    line: { color: 'red', width: 1, dash: 'dash' }
                }, {
                    type: 'line',
                    x0: validDates[0],
                    x1: validDates[validDates.length - 1],
                    y0: -1.96,
                    y1: -1.96,
                    line: { color: 'red', width: 1, dash: 'dash' }
                });
            }
            
            Plotly.newPlot('rolling-tstat-chart', [trace], {
                title: `Rolling t-stat (60D) - ${data.factor || selectedRollingFactor}`,
                xaxis: { title: 'Date' },
                yaxis: { title: 't-stat Value' },
                hovermode: 'x unified',
                template: 'plotly_white',
                shapes: shapes
            });
        } catch (error) {
            console.error('Rolling t-stat Failed to load:', error);
            document.getElementById('rolling-tstat-chart').innerHTML = '<p class="text-danger text-center py-5">Failed to load</p>';
        }
    }

    // 4. Load Factor List
    async function loadFactorList() {
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/factors` : '/api/factor-diagnostics/factors';
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.factors || data.factors.length === 0) {
                console.warn('Factor list is empty:', data.error || 'No data');
                document.getElementById('factor-select').innerHTML = '<option value="">No factors available</option>';
                return;
            }
            
            const select = document.getElementById('factor-select');
            select.innerHTML = '<option value="">Please select a factor</option>';
            // Show all factors, no quantity limit
            data.factors.forEach(factor => {
                const option = document.createElement('option');
                option.value = factor;
                option.textContent = factor;
                select.appendChild(option);
            });
        } catch (error) {
            console.error('Factor list failed to load:', error);
            document.getElementById('factor-select').innerHTML = '<option value="">Failed to load</option>';
        }
    }

    // 5. Load Long-Short Performance
    async function loadLongShortPerformance() {
        const factor = document.getElementById('factor-select').value;
        if (!factor) {
            document.getElementById('long-short-chart').innerHTML = '<p class="text-muted text-center py-5">Please select a factor first</p>';
            return;
        }
        
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/long-short?factor=${encodeURIComponent(factor)}` : `/api/factor-diagnostics/long-short?factor=${encodeURIComponent(factor)}`;
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.dates || data.dates.length === 0) {
                console.warn('Long-Short Performance data is empty:', data.error || 'No data');
                document.getElementById('long-short-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                document.getElementById('long-short-table').innerHTML = '';
                return;
            }
        
        // Use cumulative returns for display
        const cumLong = data.cum_long || [];
        const cumShort = data.cum_short || [];
        const cumLs = data.cum_ls || [];
        
        const traces = [
            {
                x: data.dates,
                y: cumLong,
                type: 'scatter',
                mode: 'lines',
                name: 'Long (Top 20%)',
                line: { color: '#28a745', width: 2, dash: 'dot' }
            },
            {
                x: data.dates,
                y: cumShort,
                type: 'scatter',
                mode: 'lines',
                name: 'Short (Bottom 20%)',
                line: { color: '#dc3545', width: 2, dash: 'dot' }
            },
            {
                x: data.dates,
                y: cumLs,
                type: 'scatter',
                mode: 'lines',
                name: 'Long-Short (Long - Short)',
                line: { color: '#007bff', width: 3 }
            }
        ];
        
        Plotly.newPlot('long-short-chart', traces, {
            title: `Long-Short Portfolio Performance: ${factor}`,
            xaxis: { title: 'Date' },
            yaxis: { title: 'Cumulative Return' },
            hovermode: 'x unified',
            template: 'plotly_white',
            legend: { x: 0, y: 1 }
        });
        
        // Show statistics table - emphasize Long-Short metrics
        const lsAnnualReturn = data.stats.long_short_annual_return || 0;
        const lsSharpe = data.stats.long_short_sharpe || 0;
        const lsMaxDd = data.stats.long_short_max_dd || 0;
        
        // Determine if factor is negatively predictive
        const isNegativePredictive = lsAnnualReturn < 0;
        const factorInterpretation = isNegativePredictive 
            ? '<div class="alert alert-warning mt-2 mb-0"><small><strong>⚠️ Negative Predictive Factor:</strong> Short portfolio outperforms Long portfolio. Consider reversing the factor sign for trading.</small></div>'
            : '<div class="alert alert-success mt-2 mb-0"><small><strong>✅ Positive Predictive Factor:</strong> Factor shows positive predictive power.</small></div>';
        
        const table = `
            <h6 class="mb-2">Performance Metrics</h6>
            <table class="table table-striped table-sm">
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th>Long-Short (Primary)</th>
                        <th class="text-muted">Long (Reference)</th>
                        <th class="text-muted">Short (Reference)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Annual Return</strong></td>
                        <td><strong>${(lsAnnualReturn * 100).toFixed(2)}%</strong></td>
                        <td class="text-muted">${(data.stats.long_annual_return * 100).toFixed(2)}%</td>
                        <td class="text-muted">${(data.stats.short_annual_return * 100).toFixed(2)}%</td>
                    </tr>
                    <tr>
                        <td><strong>Sharpe Ratio</strong></td>
                        <td><strong>${lsSharpe.toFixed(2)}</strong></td>
                        <td class="text-muted">${data.stats.long_sharpe.toFixed(2)}</td>
                        <td class="text-muted">${data.stats.short_sharpe.toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td><strong>Max Drawdown</strong></td>
                        <td><strong>${(lsMaxDd * 100).toFixed(2)}%</strong></td>
                        <td class="text-muted">${(data.stats.long_max_dd * 100).toFixed(2)}%</td>
                        <td class="text-muted">${(data.stats.short_max_dd * 100).toFixed(2)}%</td>
                    </tr>
                </tbody>
            </table>
            ${factorInterpretation}
        `;
        document.getElementById('long-short-table').innerHTML = table;
        } catch (error) {
            console.error('Long-Short Performance Failed to load:', error);
            document.getElementById('long-short-chart').innerHTML = '<p class="text-danger text-center py-5">Failed to load</p>';
            document.getElementById('long-short-table').innerHTML = '';
        }
    }

    // 6. Load Factor Clusters Analysis (Barra-style)
    async function loadFactorClusters() {
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/clusters` : '/api/factor-diagnostics/clusters';
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error) {
                console.error('Factor Clusters Analysis error:', data.error);
                document.getElementById('factor-cluster-chart').innerHTML = `<p class="text-danger text-center py-5"><strong>Error:</strong> ${data.error}<br><small>Please ensure factor_style_exposure.parquet exists in data/factors/</small></p>`;
                document.getElementById('factor-cluster-table').innerHTML = '';
                document.getElementById('factor-cluster-explanation').innerHTML = '';
                return;
            }
            
            if (!data.clusters || typeof data.clusters !== 'object') {
                console.warn('Factor Clusters Analysis data is empty: clusters is missing or invalid');
                document.getElementById('factor-cluster-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                document.getElementById('factor-cluster-table').innerHTML = '';
                document.getElementById('factor-cluster-explanation').innerHTML = '';
                return;
            }
        
        // Get economic style categories (Custom is excluded from main plot)
        const categories = Object.keys(data.clusters || {}).sort();
        
        // Get Custom and degenerate factors (separate from main plot)
        const customFactors = data.custom_factors || [];
        const degenerateFactors = data.degenerate_factors || [];
        const metadata = data.metadata || {};
        
        // Color scheme matching Barra-style risk exposure colors (MUST MATCH EXACTLY)
        // This ensures visual consistency across Multi-Factor Risk Exposure and Factor Distribution
        const barraColorMap = {
            'Momentum': '#F18F01',         // Orange
            'Trend': '#A23B72',            // Purple
            'Volatility': '#C73E1D',       // Red
            'Liquidity': '#6A994E',        // Green
            'Price/Level': '#2E86AB',      // Blue
            'Quality/Stability': '#BC4749', // Dark red (optional)
            'Custom': '#8B7E74'            // Gray (fallback only)
        };
        
        // Create scatter plot (IC vs ICIR)
        const traces = [];
        
        categories.forEach((category) => {
            const factors = data.clusters[category] || [];
            if (factors.length > 0) {
                const ic_values = factors.map(f => f.ic_mean || 0);
                const icir_values = factors.map(f => (f.icir !== null && f.icir !== undefined) ? f.icir : 0);
                
                traces.push({
                    x: ic_values,
                    y: icir_values,
                    mode: 'markers',
                    type: 'scatter',
                    name: category,  // Use exact Barra category name
                    text: factors.map(f => {
                        // Build hover text with factor metadata (MUST include numeric top_style_exposure)
                        let hover = `<b>${f.name}</b>`;
                        
                        // Dominant style (required)
                        if (f.dominant_style) {
                            hover += `<br>Dominant Style: ${f.dominant_style}`;
                        }
                        
                        // Top Style Exposure (string format: "Style: value" or "Below threshold (<threshold>)")
                        if (f.top_style_exposure) {
                            hover += `<br>Top Style Exposure: ${f.top_style_exposure}`;
                        }
                        
                        // Validate Custom factors show correct format
                        if (f.dominant_style === 'Custom' && f.top_style_exposure && f.top_style_exposure.includes(':')) {
                            console.error(`Invalid Custom factor exposure format: ${f.name} shows ${f.top_style_exposure}`);
                        }
                        
                        // Top exposures dict (for detailed breakdown - top 2 styles)
                        if (f.top_exposures && Object.keys(f.top_exposures).length > 0) {
                            const top2 = Object.entries(f.top_exposures)
                                .slice(0, 2)
                                .map(([style, exp]) => `${style}: ${parseFloat(exp).toFixed(3)}`)
                                .join(', ');
                            hover += `<br>Top 2 Exposures: ${top2}`;
                        }
                        
                        return hover;
                    }),
                    marker: { 
                        size: 12, 
                        color: barraColorMap[category] || '#666666'  // Use mapped color or gray default
                    },
                    hovertemplate: '<b>%{text}</b><br>Mean IC: %{x:.4f}<br>ICIR: %{y:.4f}<extra></extra>'
                });
            }
        });
        
        Plotly.newPlot('factor-cluster-chart', traces, {
            title: {
                text: 'Factor Distribution by Barra Style (IC vs ICIR)',
                font: { size: 18 }
            },
            xaxis: { 
                title: { text: 'Mean IC', font: { size: 14 } },
                titlefont: { size: 14 },
                tickfont: { size: 12 }
            },
            yaxis: { 
                title: { text: 'ICIR', font: { size: 14 } },
                titlefont: { size: 14 },
                tickfont: { size: 12 }
            },
            hovermode: 'closest',
            template: 'plotly_white',
            height: 600,
            margin: { l: 80, r: 50, t: 80, b: 80 },
            legend: {
                font: { size: 12 },
                x: 1.05,
                y: 1,
                xanchor: 'left',
                yanchor: 'top'
            }
        });
        
        // Show factor clusters table (dynamically using categories from API)
        let tableHtml = '<table class="table table-striped"><thead><tr><th>Barra Style</th><th>Factor</th><th>Dominant Style</th><th>Mean IC</th><th>ICIR</th><th>t-stat</th><th>Top Style Exposure</th></tr></thead><tbody>';
        categories.forEach(category => {
            const factors = data.clusters[category] || [];
            factors.forEach(factor => {
                const icir_display = (factor.icir !== null && factor.icir !== undefined) 
                    ? factor.icir.toFixed(4) 
                    : 'N/A';
                
                // Get top style exposure for display
                // Format: "Style: value" for valid styles, "Below threshold (<threshold>)" for Custom
                let topExposureDisplay = factor.top_style_exposure || 'N/A';
                
                // Validate Custom factors show correct format
                if (factor.dominant_style === 'Custom') {
                    if (topExposureDisplay.includes(':') || (!topExposureDisplay.includes('Below threshold'))) {
                        console.error(`Invalid Custom factor exposure format for ${factor.name}: ${topExposureDisplay}`);
                        topExposureDisplay = 'Below threshold';
                    }
                }
                
                tableHtml += `<tr>
                    <td><strong>${category}</strong></td>
                    <td>${factor.name}</td>
                    <td>${factor.dominant_style || category}</td>
                    <td>${(factor.ic_mean || 0).toFixed(4)}</td>
                    <td>${icir_display}</td>
                    <td>${(factor.tstat || 0).toFixed(2)}</td>
                    <td>${topExposureDisplay}</td>
                </tr>`;
            });
        });
        tableHtml += '</tbody></table>';
        
        // Add Custom factors section (if any) - NOT as an economic style
        if (customFactors.length > 0) {
            tableHtml += `<div class="mt-4">
                <h6 class="text-muted"><i class="fas fa-info-circle me-2"></i>Custom Factors (Below Exposure Threshold)</h6>
                <p class="small text-muted mb-2">
                    ${customFactors.length} factors classified as Custom (max absolute exposure < threshold). 
                    These are residual/fallback classifications, not economic styles.
                </p>
                <table class="table table-sm table-striped">
                    <thead>
                        <tr>
                            <th>Factor</th>
                            <th>Mean IC</th>
                            <th>ICIR</th>
                            <th>Top Style Exposure</th>
                        </tr>
                    </thead>
                    <tbody>`;
            customFactors.slice(0, 10).forEach(factor => {  // Show first 10 Custom factors
                const icir_display = (factor.icir !== null && factor.icir !== undefined) 
                    ? factor.icir.toFixed(4) 
                    : 'N/A';
                tableHtml += `<tr>
                    <td>${factor.name}</td>
                    <td>${(factor.ic_mean || 0).toFixed(4)}</td>
                    <td>${icir_display}</td>
                    <td class="text-muted">${factor.top_style_exposure || 'Below threshold'}</td>
                </tr>`;
            });
            if (customFactors.length > 10) {
                tableHtml += `<tr><td colspan="4" class="text-muted text-center small">... and ${customFactors.length - 10} more Custom factors</td></tr>`;
            }
            tableHtml += `</tbody></table></div>`;
        }
        
        // Add degenerate factors info (if any)
        if (degenerateFactors.length > 0) {
            tableHtml += `<div class="mt-3">
                <p class="small text-warning">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    ${degenerateFactors.length} degenerate factors excluded from plot (zero IC, N/A ICIR, or invalid data).
                </p>
            </div>`;
        }
        
        document.getElementById('factor-cluster-table').innerHTML = tableHtml;
        
        // Build explanation section dynamically based on Barra-style categories
        const barraCategoryDescriptions = {
            'Price/Level': {
                icon: 'fa-dollar-sign',
                title: 'Price/Level Factors',
                class: 'text-primary',
                description: 'Price and level factors measure absolute price levels, weighted prices, and Bollinger Band positions. These factors capture where stocks trade relative to recent price ranges. <strong>High IC values</strong> indicate that price levels contain predictive information about future returns.'
            },
            'Trend': {
                icon: 'fa-chart-line',
                title: 'Trend Factors',
                class: 'text-info',
                description: 'Trend factors capture price momentum through moving averages (SMA, EMA, WMA, DEMA) and MACD indicators. These factors identify stocks with persistent directional movements. <strong>Positive IC</strong> suggests that trends tend to continue, useful for trend-following strategies.'
            },
            'Momentum': {
                icon: 'fa-rocket',
                title: 'Momentum Factors',
                class: 'text-warning',
                description: 'Momentum factors measure price change rates (MOM, ROC), relative strength (RSI), stochastic indicators, and momentum oscillators (CCI, WILLR, ULTOSC). These factors capture short-term price acceleration. <strong>High ICIR</strong> indicates consistent momentum effects over time.'
            },
            'Volatility': {
                icon: 'fa-wave-square',
                title: 'Volatility Factors',
                class: 'text-danger',
                description: 'Volatility factors measure price uncertainty and risk (ATR, NATR, TRANGE, STDDEV, BB_WIDTH). Low volatility stocks may offer better risk-adjusted returns. <strong>Negative IC</strong> may indicate market preference for low-volatility stocks (risk-aversion behavior).'
            },
            'Liquidity': {
                icon: 'fa-water',
                title: 'Liquidity Factors',
                class: 'text-success',
                description: 'Liquidity factors measure trading activity and volume patterns (OBV, AD, ADOSC, MFI). These factors capture market participation and information flow. High liquidity often accompanies price movements, making these factors useful for confirming trends.'
            },
            'Quality/Stability': {
                icon: 'fa-shield-alt',
                title: 'Quality/Stability Factors',
                class: 'text-secondary',
                description: 'Quality and stability factors measure financial health and earnings consistency. These factors identify companies with strong fundamentals and predictable performance. <strong>Consistently positive IC</strong> suggests that quality is rewarded over time.'
            },
            'Custom': {
                icon: 'fa-cog',
                title: 'Custom Factors',
                class: 'text-dark',
                description: 'Custom factors include project-specific signals and Alpha factors. These are typically alpha signals rather than risk factors, but are included here for completeness. <strong>Evaluate individually</strong> based on IC, ICIR, and t-stat metrics.'
            }
        };
        
        // Build explanation HTML only for existing categories
        let leftColumnHtml = '';
        let rightColumnHtml = '';
        
        categories.forEach((category, index) => {
            const desc = barraCategoryDescriptions[category];
            if (!desc) {
                // If category not in descriptions, create a generic entry
                leftColumnHtml += `<h6 class="text-dark"><strong>${category}</strong></h6>`;
                leftColumnHtml += `<p class="small mb-3">Factors classified under the ${category} style bucket according to Barra taxonomy.</p>`;
                return;
            }
            
            const categoryHtml = `
                <h6 class="${desc.class}"><i class="fas ${desc.icon} me-2"></i>${desc.title}</h6>
                <p class="small mb-3">${desc.description}</p>
            `;
            
            // Distribute categories between left and right columns
            if (index < Math.ceil(categories.length / 2)) {
                leftColumnHtml += categoryHtml;
            } else {
                rightColumnHtml += categoryHtml;
            }
        });
        
        // Add chart interpretation guide to the right column
        rightColumnHtml += `
            <h6><i class="fas fa-chart-area me-2"></i>Chart Interpretation Guide</h6>
            <ul class="small">
                <li><strong>X-axis (Mean IC)</strong>: Correlation between factor and future returns. 
                    Absolute value indicates predictive power; higher = stronger signal.</li>
                <li><strong>Y-axis (ICIR)</strong>: Information Ratio = IC mean / IC std, measuring 
                    factor stability over time. Higher ICIR = more consistent performance.</li>
                <li><strong>Top-right quadrant</strong>: Ideal region with both high IC and high ICIR, 
                    indicating effective and stable factors worth including in strategies.</li>
                <li><strong>t-stat</strong>: Statistical significance. |t-stat| > 2 typically indicates 
                    significant factor performance (95% confidence level).</li>
            </ul>
            <div class="alert alert-info small mt-3 mb-0">
                <strong>Important:</strong> This analysis uses the <strong>same Barra-style classification</strong> as the Multi-Factor Risk Exposure model. Factors are grouped by economic definitions, not machine learning clustering. This ensures consistency across the entire factor diagnostics pipeline.
            </div>
        `;
        
        // Build final explanation HTML
        const explanationHtml = `
            <div class="mt-4 p-4 bg-light rounded">
                <h5><i class="fas fa-info-circle me-2"></i>Factor Distribution by Barra Style - Interpretation</h5>
                <div class="row">
                    <div class="col-md-6">
                        ${leftColumnHtml}
                    </div>
                    <div class="col-md-6">
                        ${rightColumnHtml}
                    </div>
                </div>
            </div>
        `;
        document.getElementById('factor-cluster-explanation').innerHTML = explanationHtml;
        } catch (error) {
            console.error('Factor Clusters Analysis failed to load:', error);
            document.getElementById('factor-cluster-chart').innerHTML = '<p class="text-danger text-center py-5">Failed to load</p>';
            document.getElementById('factor-cluster-table').innerHTML = '';
            document.getElementById('factor-cluster-explanation').innerHTML = '';
        }
    }

    // 7. Load Correlation Matrix
    async function loadCorrelationMatrix() {
        try {
            const method = 'pearson';  // Fixed to Pearson
            const topK = document.getElementById('correlation-top-k').value;
            const url = API_BASE_URL 
                ? `${API_BASE_URL}/api/factor-diagnostics/correlation?method=${method}&top_k=${topK}`
                : `/api/factor-diagnostics/correlation?method=${method}&top_k=${topK}`;
            
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.factors || data.factors.length === 0) {
                console.warn('Correlation matrix data is empty:', data.error || 'No data');
                document.getElementById('correlation-matrix-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                return;
            }
        
            const actualTopK = data.top_k || data.factors.length;
            
            // Create heatmap trace
            const trace = {
                z: data.correlation_matrix,
                x: data.factors,
                y: data.factors,
                type: 'heatmap',
                colorscale: 'RdBu',
                zmid: 0,
                zmin: -1,
                zmax: 1,
                hovertemplate: 'Factor X: %{x}<br>Factor Y: %{y}<br>Correlation: %{z:.3f}<extra></extra>'
            };
            
            // Update chart with dynamic title and explanatory note
            const layout = {
                title: {
                    text: `Factor Correlation Matrix (Top ${actualTopK} Factors by ICIR)`,
                    font: { size: 18 }
                },
                annotations: [{
                    text: `This matrix shows pairwise correlations among the top ${actualTopK} candidate factors selected for modeling. It is used to diagnose redundancy and multicollinearity, not to visualize the entire factor library.`,
                    showarrow: false,
                    x: 0.5,
                    y: -0.15,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'top',
                    font: { size: 11, color: '#666' }
                }],
                xaxis: {
                    title: 'Factor',
                    tickangle: -45,
                    tickfont: { size: 9 }
                },
                yaxis: {
                    title: 'Factor',
                    tickfont: { size: 9 }
                },
                template: 'plotly_white',
                // Limit chart size to prevent blocking content below
                width: Math.min(1200, Math.max(800, actualTopK * 12)),  // Max width 1200px
                height: Math.min(900, Math.max(600, actualTopK * 12)),  // Max height 900px
                margin: { l: 120, r: 50, t: 100, b: 150 },  // Extra margin for labels
                // Add scrollbar for large matrices
                autosize: false
            };
        
            Plotly.newPlot('correlation-matrix-chart', [trace], layout).then(() => {
                // Explicitly trigger layout reflow after Plotly renders
                // This ensures the chart height is committed to document flow
                requestAnimationFrame(() => {
                    // Force Plotly to recalculate and commit dimensions
                    Plotly.Plots.resize(document.getElementById('correlation-matrix-chart'));
                    
                    // Double-check: ensure wrapper has proper height
                    const wrapper = document.getElementById('factor-correlation-plot-wrapper');
                    const chart = document.getElementById('correlation-matrix-chart');
                    if (wrapper && chart) {
                        const chartHeight = chart.offsetHeight || chart.clientHeight;
                        if (chartHeight > 0) {
                            wrapper.style.minHeight = Math.max(700, chartHeight + 50) + 'px';
                        }
                    }
                });
            }).catch(error => {
                console.error('Plotly plot error:', error);
                document.getElementById('correlation-matrix-chart').innerHTML = '<p class="text-danger text-center py-5">Failed to load</p>';
            });
        } catch (error) {
            console.error('Correlation matrix failed to load:', error);
            document.getElementById('correlation-matrix-chart').innerHTML = '<p class="text-danger text-center py-5">Failed to load</p>';
        }
    }

    // 8. Load Risk Exposure
    async function loadRiskExposure() {
        try {
            let date = document.getElementById('exposure-date').value;
            if (!date) {
                // If no date selected, use latest date
                try {
                    const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/latest-date` : '/api/factor-diagnostics/latest-date';
                    const response = await fetch(url);
                    const data = await response.json();
                    if (data.date && !data.error) {
                        document.getElementById('exposure-date').value = data.date;
                        date = data.date;
                    } else {
                        const chartEl = document.getElementById('risk-exposure-chart');
                        if (chartEl) {
                            chartEl.innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                        }
                        document.getElementById('risk-exposure-table').innerHTML = '';
                        document.getElementById('risk-exposure-explanation').innerHTML = '';
                        return; // Cannot get date, skip loading
                    }
                } catch (e) {
                    console.error('Failed to get latest date:', e);
                    const chartEl = document.getElementById('risk-exposure-chart');
                    if (chartEl) {
                        chartEl.innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                    }
                    document.getElementById('risk-exposure-table').innerHTML = '';
                    document.getElementById('risk-exposure-explanation').innerHTML = '';
                    return;
                }
            }
            
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/risk-exposure?date=${date}` : `/api/factor-diagnostics/risk-exposure?date=${date}`;
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.factors || data.factors.length === 0) {
                console.warn('Risk exposure data is empty:', data.error || 'No data');
                document.getElementById('risk-exposure-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                document.getElementById('risk-exposure-table').innerHTML = '';
                document.getElementById('risk-exposure-explanation').innerHTML = '';
                return;
            }
            
            const chartEl = document.getElementById('risk-exposure-chart');
            if (!chartEl) {
                console.error('Risk exposure chart element not found');
                return;
            }
            
            // Clear any existing error messages
            chartEl.innerHTML = '';
            
            // FRONTEND VALIDATION: Filter out any raw factors that might have slipped through
            // Valid style factors only
            const validStyleFactors = new Set([
                'Price/Level', 'Trend', 'Momentum', 'Volatility', 'Liquidity', 
                'Quality/Stability', 'Custom'
            ]);
            
            // Patterns that indicate raw factors
            const rawFactorPatterns = [
                /^Alpha/, /^AD$/, /^OBV$/, /^ADOSC/, /^BB_/, /^SMA_/, /^EMA_/, 
                /^WMA_/, /^DEMA_/, /^RSI_/, /^CCI_/, /^STOCH/, /^WILLR_/, 
                /^AROON/, /^MACD/, /^MOM_/, /^ROC_/, /^MFI_/, /^ATR_/, 
                /^NATR_/, /^BOP$/, /^CUSTOM_/
            ];
            
            function isRawFactor(factorName) {
                if (validStyleFactors.has(factorName)) {
                    return false;
                }
                return rawFactorPatterns.some(pattern => pattern.test(factorName));
            }
            
            // Filter factors to only include style factors
            const filteredFactors = [];
            const filteredExposures = [];
            const filteredRiskContributions = [];
            
            data.factors.forEach((factor, idx) => {
                if (!isRawFactor(factor)) {
                    filteredFactors.push(factor);
                    filteredExposures.push(data.exposures[idx]);
                    filteredRiskContributions.push(data.risk_contributions[idx]);
                } else {
                    console.warn(`[Risk Exposure] Filtering out raw factor '${factor}' from display`);
                }
            });
            
            // If no valid style factors, show error
            if (filteredFactors.length === 0) {
                document.getElementById('risk-exposure-chart').innerHTML = 
                    '<p class="text-danger text-center py-5">错误: 数据包含原始因子名称而非风格因子。请重新生成数据。</p>';
                document.getElementById('risk-exposure-table').innerHTML = '';
                document.getElementById('risk-exposure-explanation').innerHTML = '';
                return;
            }
            
            // Use filtered data for chart (style factors only)
            const trace = {
                x: filteredFactors,
                y: filteredExposures,
                type: 'bar',
                marker: { color: filteredExposures.map(e => e > 0 ? '#28a745' : '#dc3545') }
            };
            
            Plotly.newPlot('risk-exposure-chart', [trace], {
                title: `Risk Exposure (Barra-style) - ${date}`,
                xaxis: { title: 'Style Factor' },
                yaxis: { title: 'Exposure' },
                template: 'plotly_white'
            });
            
            // Show risk exposure table (only style factors)
            let tableHtml = '<table class="table table-striped"><thead><tr><th>Style Factor</th><th>Exposure</th><th>Risk Contribution</th></tr></thead><tbody>';
            filteredFactors.forEach((factor, idx) => {
                // Risk contribution is already in percentage from backend (0-100), no need to multiply by 100
                const riskContrib = filteredRiskContributions[idx];
                tableHtml += `<tr>
                    <td><strong>${factor}</strong></td>
                    <td>${filteredExposures[idx].toFixed(4)}</td>
                    <td>${typeof riskContrib === 'number' ? riskContrib.toFixed(2) : '0.00'}%</td>
                </tr>`;
            });
            // Add specific risk row if available
            if (data.specific_risk_contribution !== undefined && data.specific_risk_contribution !== null) {
                tableHtml += `<tr class="table-info">
                    <td><strong>Specific Risk (Idiosyncratic)</strong></td>
                    <td>-</td>
                    <td>${typeof data.specific_risk_contribution === 'number' ? data.specific_risk_contribution.toFixed(2) : '0.00'}%</td>
                </tr>`;
            }
            tableHtml += '</tbody></table>';
            document.getElementById('risk-exposure-table').innerHTML = tableHtml;
            
            // Add/update explanation section (replace existing content to avoid duplicates)
            const explanationHtml = `
                <div class="mt-4 p-4 bg-light rounded">
                    <h5><i class="fas fa-info-circle me-2"></i>Multi-Factor Risk Exposure (Barra-style) - Complete Interpretation</h5>
                    
                    <div class="row mt-3">
                        <div class="col-md-12">
                            <h6><i class="fas fa-book me-2"></i>1. What is Barra-Style Risk Exposure?</h6>
                            <p class="small mb-3">
                                This analysis uses a Barra-style multi-factor risk model following industry-standard principles to decompose portfolio risk into interpretable, independent sources. Unlike simple factor analysis, this model transforms raw factors into orthogonal style factors that represent distinct risk dimensions.
                            </p>
                            
                            <h6><i class="fas fa-cogs me-2"></i>2. Methodology: Step-by-Step Process</h6>
                            <ol class="small mb-3">
                                <li><strong>Factor Classification:</strong> Groups 160+ raw factors into 7 economically meaningful style buckets (Price/Level, Trend, Momentum, Volatility, Liquidity, Quality/Stability, Custom). Alpha factors are excluded (they are signals, not risk factors).</li>
                                <li><strong>Cross-Sectional Normalization:</strong> For each date, factors are winsorized (clipped at 1st/99th percentiles) and z-score normalized to ensure comparability across stocks.</li>
                                <li><strong>Fixed PCA Structure (Rolling Window):</strong> Using a rolling window (60-252 days, default 126 days), Principal Component Analysis loadings are estimated once and kept fixed across all dates. Within each style bucket, the first principal component (PC1) loadings are computed from the reference window and applied to all subsequent dates. This ensures time-stable factor definitions—the same raw factors map to the same style factors across time, allowing meaningful time-series analysis and consistent risk attribution.</li>
                                <li><strong>Fixed Orthogonalization Matrix:</strong> Using the same rolling window, the Gram-Schmidt orthogonalization matrix is estimated once and kept fixed. This ensures style factors are consistently orthogonalized across all dates, maintaining independence while preserving temporal stability. The orthogonalization order and transformation are fixed based on the reference window.</li>
                                <li><strong>Factor Return Estimation:</strong> Daily factor returns are estimated via cross-sectional regression: <code>r_{i,t+1} = Σ_k (β_{i,k,t} × f_{k,t+1}) + ε_{i,t+1}</code>, where exposures (β) are from time t and stock returns (r) are from time t+1 (no look-ahead bias). The factor exposures β_{i,k,t} use the fixed PCA and orthogonalization structure estimated from the rolling window, ensuring consistency across time.</li>
                                <li><strong>Factor Covariance Matrix:</strong> Time-series covariance of factor returns is estimated using EWMA (Exponentially Weighted Moving Average) with λ=0.94: <code>Σ_f = Cov(factor_returns)</code>.</li>
                                <li><strong>Risk Decomposition:</strong> Portfolio variance is computed as: <code>σ²_portfolio = b^T Σ_f b + σ²_specific</code>, where b is the vector of portfolio factor exposures.</li>
                            </ol>
                            
                            <h6><i class="fas fa-calculator me-2"></i>3. Key Formulas</h6>
                            <div class="small mb-3" style="background-color: #f8f9fa; padding: 15px; border-radius: 5px; font-family: 'Courier New', monospace;">
                                <p><strong>Portfolio Factor Exposure:</strong></p>
                                <p style="margin-left: 20px;">b_k = Σ_i (w_i × β_{i,k})</p>
                                <p style="font-size: 0.9em; color: #666;">where w_i is portfolio weight for stock i, β_{i,k} is factor k exposure for stock i (computed using fixed PCA/orthogonalization structure)</p>
                                
                                <p class="mt-3"><strong>Portfolio Variance:</strong></p>
                                <p style="margin-left: 20px;">σ²_portfolio = b^T Σ_f b + σ²_specific</p>
                                <p style="font-size: 0.9em; color: #666;">where Σ_f is factor return covariance matrix, σ²_specific is idiosyncratic risk</p>
                                
                                <p class="mt-3"><strong>Factor Risk Contribution:</strong></p>
                                <p style="margin-left: 20px;">RC_k = (b_k × (Σ_f b)_k) / σ²_portfolio × 100%</p>
                                <p style="font-size: 0.9em; color: #666;">where (Σ_f b)_k is the k-th element of the marginal contribution vector</p>
                                
                                <p class="mt-3"><strong>Specific Risk:</strong></p>
                                <p style="margin-left: 20px;">σ²_specific = Σ_i (w_i² × σ²_i)</p>
                                <p style="font-size: 0.9em; color: #666;">where σ²_i is the residual variance from factor regression for stock i</p>
                            </div>
                            
                            <h6><i class="fas fa-arrow-up me-2"></i>4. Exposure Interpretation</h6>
                            <p class="small mb-2"><strong>Positive Exposure (b_k > 0):</strong></p>
                            <p class="small mb-3" style="margin-left: 20px;">
                                The portfolio is <strong>overweight</strong> in this factor relative to the benchmark. For example, 
                                a positive momentum exposure means the portfolio holds more high-momentum stocks. This can be 
                                intentional to capture momentum effects, but also increases exposure to momentum risk.
                            </p>
                            <p class="small mb-2"><strong>Negative Exposure (b_k < 0):</strong></p>
                            <p class="small mb-3" style="margin-left: 20px;">
                                The portfolio is <strong>underweight</strong> in this factor. For example, a negative value exposure 
                                means the portfolio prefers growth stocks over value stocks. Negative exposures can serve as hedges 
                                but also represent missed opportunities if the factor performs well.
                            </p>
                            
                            <h6><i class="fas fa-percentage me-2"></i>5. Risk Contribution Interpretation</h6>
                            <p class="small mb-2"><strong>Positive Risk Contribution (RC_k > 0):</strong></p>
                            <p class="small mb-3" style="margin-left: 20px;">
                                This factor <strong>increases</strong> portfolio variance. The magnitude |RC_k| shows what percentage 
                                of total portfolio risk is attributed to this factor. Higher positive contributions indicate the 
                                factor is a major driver of portfolio volatility.
                            </p>
                            <p class="small mb-2"><strong>Negative Risk Contribution (RC_k < 0):</strong></p>
                            <p class="small mb-3" style="margin-left: 20px;">
                                This factor <strong>reduces</strong> portfolio variance (hedging effect). This occurs when the factor 
                                exposure (b_k) and marginal contribution ((Σ_f b)_k) have opposite signs. The magnitude |RC_k| still 
                                represents the factor's impact magnitude, but the negative sign indicates risk reduction rather than 
                                risk addition. This is mathematically valid and indicates the factor acts as a natural hedge.
                            </p>
                            <p class="small mb-3" style="background-color: #fff3cd; padding: 10px; border-radius: 5px; border-left: 4px solid #ffc107;">
                                <strong>Important:</strong> Risk contributions sum to 100% (including specific risk). The sign indicates 
                                direction (risk addition vs. reduction), while the absolute value indicates magnitude. A negative 
                                contribution means the factor is reducing portfolio risk, not that risk is negative.
                            </p>
                            
                            <h6><i class="fas fa-chart-line me-2"></i>6. Specific Risk</h6>
                            <p class="small mb-3">
                                <strong>Specific Risk (σ²_specific)</strong> represents idiosyncratic (stock-specific) risk that cannot 
                                be explained by systematic style factors. It captures company-specific events, earnings surprises, 
                                management changes, and other non-systematic risks. For a well-diversified portfolio with N stocks, 
                                specific risk contribution typically decreases as 1/N due to diversification. A high specific risk 
                                contribution (>20%) may indicate insufficient diversification or concentrated positions.
                            </p>
                            
                            <h6><i class="fas fa-lightbulb me-2"></i>7. How to Use This Analysis</h6>
                            <ul class="small">
                                <li><strong>Identify Concentration Risk:</strong> If one factor accounts for >50% of absolute risk 
                                    contribution, consider diversifying to reduce concentration. High concentration increases 
                                    vulnerability to that factor's performance.</li>
                                <li><strong>Monitor Factor Drift:</strong> Track exposure changes over time. Large shifts may indicate 
                                    unintended style drift or market-driven changes requiring rebalancing.</li>
                                <li><strong>Understand Hedging Effects:</strong> Negative risk contributions indicate natural hedges. 
                                    Ensure these are intentional rather than accidental, and consider if they align with your strategy.</li>
                                <li><strong>Factor Timing:</strong> Adjust exposures based on market conditions. For example, increase 
                                    quality exposure during market stress, or momentum exposure during trending markets.</li>
                                <li><strong>Rebalancing Signal:</strong> Large exposure or risk contribution changes may indicate the 
                                    need for portfolio rebalancing to maintain target factor weights and risk budget.</li>
                                <li><strong>Risk Budgeting:</strong> Use risk contributions to allocate risk budget across factors. 
                                    Ensure no single factor dominates unless intentional (e.g., factor-tilting strategies).</li>
                            </ul>
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('risk-exposure-explanation').innerHTML = explanationHtml;
        } catch (error) {
            console.error('Risk exposure failed to load:', error);
            document.getElementById('risk-exposure-chart').innerHTML = '<p class="text-danger text-center py-5">Failed to load</p>';
            document.getElementById('risk-exposure-table').innerHTML = '';
            document.getElementById('risk-exposure-explanation').innerHTML = '';
        }
    }
</script>
{% endblock %}

