{% extends "base.html" %}

{% block title %}Factor Diagnostics- Quantitative Trading Strategy Dashboard{% endblock %}

{% block extra_head %}
<style>
    .diagnostic-card {
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .metric-value {
        font-size: 1.5em;
        font-weight: bold;
    }
    .metric-label {
        color: #666;
        font-size: 0.9em;
    }
    .chart-container {
        height: 400px;
        margin-bottom: 20px;
    }
    #factor-cluster-chart {
        height: 600px !important;
    }
    .factor-category {
        padding: 10px;
        margin: 5px;
        border-radius: 5px;
        display: inline-block;
    }
    .momentum { background-color: #e3f2fd; }
    .quality { background-color: #f3e5f5; }
    .volatility { background-color: #fff3e0; }
    .value { background-color: #e8f5e9; }
    .size { background-color: #fce4ec; }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row mb-4">
        <div class="col-12">
            <h2 class="mb-0"><i class="fas fa-microscope me-2"></i>Factor Diagnostics</h2>
            <p class="text-muted">Factor evaluation, IC analysis, risk exposure and correlation analysis</p>
        </div>
    </div>

    <!-- Loading Status -->
    <div id="loading" class="text-center py-5">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-3">Loading factor diagnostics data...</p>
    </div>

    <!-- Error Message -->
    <div id="error-message" class="alert alert-danger" style="display: none;">
        <i class="fas fa-exclamation-triangle me-2"></i>
        <span id="error-text"></span>
    </div>

    <!-- Main Content -->
    <div id="main-content" style="display: none;">
        <!-- 1. Rolling IC Curve -->
        <div class="card diagnostic-card">
            <div class="card-header bg-primary text-white">
                <h5 class="mb-0"><i class="fas fa-chart-line me-2"></i>Rolling IC (60D)</h5>
            </div>
            <div class="card-body">
                <p class="text-muted small mb-2">
                    <i class="fas fa-info-circle me-1"></i>
                    Rolling statistics begin once 60 trading days of data are available.
                </p>
                <div id="rolling-ic-chart" class="chart-container"></div>
            </div>
        </div>

        <!-- 2. Rolling ICIR and t-stat -->
        <div class="row">
            <div class="col-md-6">
                <div class="card diagnostic-card">
                    <div class="card-header bg-info text-white">
                        <h5 class="mb-0"><i class="fas fa-chart-area me-2"></i>Rolling ICIR (60D)</h5>
                    </div>
                    <div class="card-body">
                        <p class="text-muted small mb-2">
                            <i class="fas fa-info-circle me-1"></i>
                            ICIR = mean(IC_60d) / std(IC_60d)
                        </p>
                        <div id="rolling-icir-chart" class="chart-container"></div>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card diagnostic-card">
                    <div class="card-header bg-warning text-dark">
                        <h5 class="mb-0"><i class="fas fa-chart-bar me-2"></i>Rolling t-stat (60D)</h5>
                    </div>
                    <div class="card-body">
                        <p class="text-muted small mb-2">
                            <i class="fas fa-info-circle me-1"></i>
                            t-stat = mean(IC_60d) / std(IC_60d) √ó ‚àöN
                        </p>
                        <div id="rolling-tstat-chart" class="chart-container"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 3. Long-Short Portfolio Performance -->
        <div class="card diagnostic-card">
            <div class="card-header bg-success text-white">
                <h5 class="mb-0"><i class="fas fa-exchange-alt me-2"></i>Long-Short Portfolio Performance (by Factor)</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="factor-select" class="form-label">Select Factor:</label>
                    <select id="factor-select" class="form-select" onchange="loadLongShortPerformance()">
                        <option value="">Loading...</option>
                    </select>
                </div>
                <div id="long-short-chart" class="chart-container"></div>
                <div id="long-short-table" class="mt-3"></div>
            </div>
        </div>

        <!-- 4. Factor Clusters Analysis -->
        <div class="card diagnostic-card">
            <div class="card-header bg-secondary text-white">
                <h5 class="mb-0"><i class="fas fa-layer-group me-2"></i>Factor Clusters Analysis (Momentum / Quality / Volatility)</h5>
            </div>
            <div class="card-body">
                <div id="factor-cluster-chart" class="chart-container"></div>
                <div id="factor-cluster-table" class="mt-3"></div>
                <div id="factor-cluster-explanation"></div>
            </div>
        </div>

        <!-- 5. Factor Correlation Matrix -->
        <div class="card diagnostic-card">
            <div class="card-header bg-dark text-white">
                <h5 class="mb-0"><i class="fas fa-th me-2"></i>Factor Correlation Matrix</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="correlation-method" class="form-label">Correlation Method:</label>
                    <select id="correlation-method" class="form-select" onchange="loadCorrelationMatrix()">
                        <option value="pearson">Pearson</option>
                    </select>
                </div>
                <div id="correlation-matrix-chart" class="chart-container" style="height: 600px;"></div>
            </div>
        </div>

        <!-- 6. Multi-Factor Risk Exposure (Barra-style) -->
        <div class="card diagnostic-card">
            <div class="card-header bg-danger text-white">
                <h5 class="mb-0"><i class="fas fa-shield-alt me-2"></i>Multi-Factor Risk Exposure (Barra-style)</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="exposure-date" class="form-label">Select Date:</label>
                    <input type="date" id="exposure-date" class="form-control" onchange="loadRiskExposure()">
                </div>
                <div id="risk-exposure-chart" class="chart-container"></div>
                <div id="risk-exposure-table" class="mt-3"></div>
                <div id="risk-exposure-explanation"></div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    // API_BASE_URL is already declared in base.html, use it directly here

    // Initialize on page load
    function initPage() {
        console.log('Initializing page, DOM Status:', document.readyState);
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                console.log('DOMContentLoaded event triggered');
                setTimeout(() => loadAllDiagnostics(), 100);
            });
        } else {
            console.log('DOM ready, execute directly');
            setTimeout(() => loadAllDiagnostics(), 100);
        }
    }
    
    // Add timeout protection: if still loading after 10 seconds, force display content
    setTimeout(() => {
        const loadingEl = document.getElementById('loading');
        const mainContentEl = document.getElementById('main-content');
        if (loadingEl && loadingEl.style.display !== 'none') {
            console.warn('Loading timeout, force display content');
            if (loadingEl) loadingEl.style.display = 'none';
            if (mainContentEl) mainContentEl.style.display = 'block';
        }
    }, 10000);
    
    // Execute initialization immediately
    initPage();

    // Load all diagnostic data
    async function loadAllDiagnostics() {
        try {
            console.log('Starting to load factor diagnostics data...');
            
            // Check if DOM elements exist
            const loadingEl = document.getElementById('loading');
            const mainContentEl = document.getElementById('main-content');
            const errorEl = document.getElementById('error-message');
            
            if (!loadingEl || !mainContentEl) {
                console.error('DOM elements do not exist! loading:', !!loadingEl, 'main-content:', !!mainContentEl);
                return;
            }
            
            // Load all data in parallel (improve speed)
            // Use Promise.allSettled to ensure continuation even if some fail
            const promises = [
                loadRollingIC().catch(e => { console.error('Rolling IC failed:', e); return { error: e }; }),
                loadRollingICIR().catch(e => { console.error('Rolling ICIR failed:', e); return { error: e }; }),
                loadRollingTStat().catch(e => { console.error('Rolling t-stat failed:', e); return { error: e }; }),
                loadFactorList().catch(e => { console.error('Factor list failed:', e); return { error: e }; }),
                loadFactorClusters().catch(e => { console.error('Factor Clusters Analysis failed:', e); return { error: e }; }),
                loadCorrelationMatrix().catch(e => { console.error('Correlation matrix failed:', e); return { error: e }; }),
                loadRiskExposure().catch(e => { console.error('Risk exposure failed:', e); return { error: e }; })
            ];
            
            console.log('Waiting for all promises to complete...');
            const results = await Promise.allSettled(promises);
            console.log('Promise results:', results.map((r, i) => ({ index: i, status: r.status, value: r.status === 'fulfilled' ? 'ok' : r.reason })));
            
            console.log('All diagnostic data loaded (some may have failed)');
            
            // Show main content (even if some data failed to load)
            loadingEl.style.display = 'none';
            mainContentEl.style.display = 'block';
            console.log('Hide loading, show main content');
        } catch (error) {
            console.error('Failed to load diagnostic data:', error);
            console.error('Error stack:', error.stack);
            
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error-message');
            const errorTextEl = document.getElementById('error-text');
            
            if (loadingEl) loadingEl.style.display = 'none';
            if (errorEl) errorEl.style.display = 'block';
            if (errorTextEl) errorTextEl.textContent = 'Failed to load: ' + (error.message || 'Unknown error');
        }
    }

    // 1. Load Rolling IC
    async function loadRollingIC() {
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/rolling-ic` : '/api/factor-diagnostics/rolling-ic';
            console.log('[Rolling IC] Requesting URL:', url);
            console.log('[Rolling IC] No date filters applied - requesting full history');
            const response = await fetch(url);
            const data = await response.json();
            
            // Log debugging information
            if (data._debug) {
                console.log('[Rolling IC] Debug info:', {
                    raw_ic_count: data._debug.raw_ic_count,
                    non_null_ic_count: data._debug.non_null_ic_count,
                    returned_count: data._debug.returned_count,
                    date_min: data._debug.date_min,
                    date_max: data._debug.date_max,
                    rolling_window: data._debug.rolling_window,
                    actual_dates_length: data.dates ? data.dates.length : 0
                });
            }
            
            if (data.error || !data.dates || data.dates.length === 0) {
                console.warn('Rolling IC data is empty:', data.error || 'No data');
                document.getElementById('rolling-ic-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                return;
            }
            
            // Filter out null/NaN values for plotting
            const validIcMean = [];
            const validIcUpper = [];
            const validIcLower = [];
            const validDates = [];
            data.ic_mean.forEach((value, index) => {
                if (value !== null && value !== undefined && !isNaN(value)) {
                    validIcMean.push(value);
                    validIcUpper.push(data.ic_upper[index]);
                    validIcLower.push(data.ic_lower[index]);
                    validDates.push(data.dates[index]);
                }
            });
            
            if (validIcMean.length === 0) {
                const daysAvailable = data.dates ? data.dates.length : 0;
                const message = daysAvailable < 60 
                    ? `Insufficient data: ${daysAvailable} trading days available. Rolling IC requires at least 60 trading days.`
                    : 'No valid Rolling IC data available';
                document.getElementById('rolling-ic-chart').innerHTML = 
                    `<div class="text-center py-5">
                        <p class="text-muted mb-2"><i class="fas fa-info-circle me-1"></i>Rolling statistics begin once 60 trading days of data are available.</p>
                        <p class="text-muted"><i class="fas fa-exclamation-triangle me-1"></i>${message}</p>
                    </div>`;
                return;
            }
            
            const trace = {
                x: validDates,
                y: validIcMean,
                type: 'scatter',
                mode: 'lines',
                name: 'Mean IC',
                line: { color: '#2E86AB', width: 2 }
            };
            
            const trace_upper = {
                x: validDates,
                y: validIcUpper,
                type: 'scatter',
                mode: 'lines',
                name: 'Upper Bound',
                line: { color: '#A23B72', width: 1, dash: 'dash' },
                fill: 'tonexty',
                fillcolor: 'rgba(162, 59, 114, 0.1)',
                showlegend: false
            };
            
            const trace_lower = {
                x: validDates,
                y: validIcLower,
                type: 'scatter',
                mode: 'lines',
                name: 'Lower Bound',
                line: { color: '#A23B72', width: 1, dash: 'dash' },
                fill: 'tozeroy',
                fillcolor: 'rgba(162, 59, 114, 0.1)',
                showlegend: false
            };
            
            const chartEl = document.getElementById('rolling-ic-chart');
            if (chartEl) {
                Plotly.newPlot('rolling-ic-chart', [trace_lower, trace_upper, trace], {
                    title: 'Rolling IC (60D)',
                    xaxis: { title: 'Date' },
                    yaxis: { title: 'IC Value' },
                    hovermode: 'x unified',
                    template: 'plotly_white'
                });
                console.log('[Rolling IC] Chart rendered');
            } else {
                console.warn('[Rolling IC] Chart element does not exist');
            }
        } catch (error) {
            console.error('[Rolling IC] Failed to load:', error);
            const chartEl = document.getElementById('rolling-ic-chart');
            if (chartEl) {
                chartEl.innerHTML = '<p class="text-danger text-center py-5">Failed to load: ' + error.message + '</p>';
            }
            // Don't rethrow, let other charts continue loading
        }
    }

    // 2. Load Rolling ICIR
    async function loadRollingICIR() {
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/rolling-icir` : '/api/factor-diagnostics/rolling-icir';
            console.log('[Rolling ICIR] Requesting URL:', url);
            console.log('[Rolling ICIR] No date filters applied - requesting full history');
            const response = await fetch(url);
            const data = await response.json();
            
            // Log debugging information
            if (data._debug) {
                console.log('[Rolling ICIR] Debug info:', {
                    raw_ic_count: data._debug.raw_ic_count,
                    non_null_ic_count: data._debug.non_null_ic_count,
                    returned_count: data._debug.returned_count,
                    date_min: data._debug.date_min,
                    date_max: data._debug.date_max,
                    rolling_window: data._debug.rolling_window,
                    actual_dates_length: data.dates ? data.dates.length : 0
                });
            }
            
            if (data.error || !data.dates || data.dates.length === 0) {
                console.warn('Rolling ICIR data is empty:', data.error || 'No data');
                document.getElementById('rolling-icir-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                return;
            }
            
            // Filter out NaN values for plotting
            const validData = [];
            const validDates = [];
            data.icir.forEach((value, index) => {
                if (value !== null && value !== undefined && !isNaN(value)) {
                    validData.push(value);
                    validDates.push(data.dates[index]);
                }
            });
            
            if (validData.length === 0) {
                console.warn('Rolling ICIR: No valid data after filtering NaN');
                const daysAvailable = data.dates ? data.dates.length : 0;
                const message = daysAvailable < 60 
                    ? `Insufficient data: ${daysAvailable} trading days available. Rolling ICIR requires at least 60 trading days.`
                    : 'No valid ICIR data available';
                document.getElementById('rolling-icir-chart').innerHTML = 
                    `<div class="text-center py-5">
                        <p class="text-muted mb-2"><i class="fas fa-info-circle me-1"></i>ICIR = mean(IC_60d) / std(IC_60d)</p>
                        <p class="text-muted"><i class="fas fa-exclamation-triangle me-1"></i>${message}</p>
                    </div>`;
                return;
            }
            
            const trace = {
                x: validDates,
                y: validData,
                type: 'scatter',
                mode: 'lines',
                name: 'ICIR',
                line: { color: '#17a2b8', width: 2 }
            };
            
            const chartEl = document.getElementById('rolling-icir-chart');
            if (chartEl) {
                Plotly.newPlot('rolling-icir-chart', [trace], {
                    title: 'Rolling ICIR (60D)',
                    xaxis: { title: 'Date' },
                    yaxis: { title: 'ICIR Value' },
                    hovermode: 'x unified',
                    template: 'plotly_white'
                });
            }
        } catch (error) {
            console.error('Rolling ICIR Failed to load:', error);
            const chartEl = document.getElementById('rolling-icir-chart');
            if (chartEl) {
                chartEl.innerHTML = '<p class="text-danger text-center py-5">Failed to load: ' + (error.message || 'Unknown error') + '</p>';
            }
        }
    }

    // 3. Load Rolling t-stat
    async function loadRollingTStat() {
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/rolling-tstat` : '/api/factor-diagnostics/rolling-tstat';
            console.log('[Rolling t-stat] Requesting URL:', url);
            console.log('[Rolling t-stat] No date filters applied - requesting full history');
            const response = await fetch(url);
            const data = await response.json();
            
            // Log debugging information
            if (data._debug) {
                console.log('[Rolling t-stat] Debug info:', {
                    raw_ic_count: data._debug.raw_ic_count,
                    non_null_ic_count: data._debug.non_null_ic_count,
                    returned_count: data._debug.returned_count,
                    date_min: data._debug.date_min,
                    date_max: data._debug.date_max,
                    rolling_window: data._debug.rolling_window,
                    actual_dates_length: data.dates ? data.dates.length : 0
                });
            }
            
            if (data.error || !data.dates || data.dates.length === 0) {
                console.warn('Rolling t-stat data is empty:', data.error || 'No data');
                document.getElementById('rolling-tstat-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                return;
            }
            
            // Filter out null/NaN values for plotting
            const validData = [];
            const validDates = [];
            data.tstat.forEach((value, index) => {
                if (value !== null && value !== undefined && !isNaN(value)) {
                    validData.push(value);
                    validDates.push(data.dates[index]);
                }
            });
            
            if (validData.length === 0) {
                console.warn('Rolling t-stat: No valid data after filtering NaN');
                const daysAvailable = data.dates ? data.dates.length : 0;
                const message = daysAvailable < 60 
                    ? `Insufficient data: ${daysAvailable} trading days available. Rolling t-stat requires at least 60 trading days.`
                    : 'No valid t-stat data available';
                document.getElementById('rolling-tstat-chart').innerHTML = 
                    `<div class="text-center py-5">
                        <p class="text-muted mb-2"><i class="fas fa-info-circle me-1"></i>t-stat = mean(IC_60d) / std(IC_60d) √ó ‚àöN</p>
                        <p class="text-muted"><i class="fas fa-exclamation-triangle me-1"></i>${message}</p>
                    </div>`;
                return;
            }
            
            const trace = {
                x: validDates,
                y: validData,
                type: 'scatter',
                mode: 'lines',
                name: 't-stat',
                line: { color: '#ffc107', width: 2 }
            };
            
            const shapes = [];
            if (validDates.length > 0) {
                shapes.push({
                    type: 'line',
                    x0: validDates[0],
                    x1: validDates[validDates.length - 1],
                    y0: 1.96,
                    y1: 1.96,
                    line: { color: 'red', width: 1, dash: 'dash' }
                }, {
                    type: 'line',
                    x0: validDates[0],
                    x1: validDates[validDates.length - 1],
                    y0: -1.96,
                    y1: -1.96,
                    line: { color: 'red', width: 1, dash: 'dash' }
                });
            }
            
            Plotly.newPlot('rolling-tstat-chart', [trace], {
                title: 'Rolling t-stat (60D)',
                xaxis: { title: 'Date' },
                yaxis: { title: 't-stat Value' },
                hovermode: 'x unified',
                template: 'plotly_white',
                shapes: shapes
            });
        } catch (error) {
            console.error('Rolling t-stat Failed to load:', error);
            document.getElementById('rolling-tstat-chart').innerHTML = '<p class="text-danger text-center py-5">Failed to load</p>';
        }
    }

    // 4. Load Factor List
    async function loadFactorList() {
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/factors` : '/api/factor-diagnostics/factors';
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.factors || data.factors.length === 0) {
                console.warn('Factor list is empty:', data.error || 'No data');
                document.getElementById('factor-select').innerHTML = '<option value="">No factors available</option>';
                return;
            }
            
            const select = document.getElementById('factor-select');
            select.innerHTML = '<option value="">Please select a factor</option>';
            // Show all factors, no quantity limit
            data.factors.forEach(factor => {
                const option = document.createElement('option');
                option.value = factor;
                option.textContent = factor;
                select.appendChild(option);
            });
        } catch (error) {
            console.error('Factor list failed to load:', error);
            document.getElementById('factor-select').innerHTML = '<option value="">Failed to load</option>';
        }
    }

    // 5. Load Long-Short Performance
    async function loadLongShortPerformance() {
        const factor = document.getElementById('factor-select').value;
        if (!factor) {
            document.getElementById('long-short-chart').innerHTML = '<p class="text-muted text-center py-5">Please select a factor first</p>';
            return;
        }
        
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/long-short?factor=${encodeURIComponent(factor)}` : `/api/factor-diagnostics/long-short?factor=${encodeURIComponent(factor)}`;
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.dates || data.dates.length === 0) {
                console.warn('Long-Short Performance data is empty:', data.error || 'No data');
                document.getElementById('long-short-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                document.getElementById('long-short-table').innerHTML = '';
                return;
            }
        
        const traces = [
            {
                x: data.dates,
                y: data.long_returns,
                type: 'scatter',
                mode: 'lines',
                name: 'Long Portfolio',
                line: { color: '#28a745', width: 2 }
            },
            {
                x: data.dates,
                y: data.short_returns,
                type: 'scatter',
                mode: 'lines',
                name: 'Short Portfolio',
                line: { color: '#dc3545', width: 2 }
            },
            {
                x: data.dates,
                y: data.long_short_returns,
                type: 'scatter',
                mode: 'lines',
                name: 'Long-Short',
                line: { color: '#007bff', width: 2 }
            }
        ];
        
        Plotly.newPlot('long-short-chart', traces, {
            title: `Long-Short Portfolio Performance: ${factor}`,
            xaxis: { title: 'Date' },
            yaxis: { title: 'Cumulative Return' },
            hovermode: 'x unified',
            template: 'plotly_white'
        });
        
        // Show statistics table
        const table = `
            <table class="table table-striped">
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th>Long</th>
                        <th>Short</th>
                        <th>Long-Short</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Annual Return</td>
                        <td>${(data.stats.long_annual_return * 100).toFixed(2)}%</td>
                        <td>${(data.stats.short_annual_return * 100).toFixed(2)}%</td>
                        <td>${(data.stats.long_short_annual_return * 100).toFixed(2)}%</td>
                    </tr>
                    <tr>
                        <td>Sharpe Ratio</td>
                        <td>${data.stats.long_sharpe.toFixed(2)}</td>
                        <td>${data.stats.short_sharpe.toFixed(2)}</td>
                        <td>${data.stats.long_short_sharpe.toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td>Max Drawdown</td>
                        <td>${(data.stats.long_max_dd * 100).toFixed(2)}%</td>
                        <td>${(data.stats.short_max_dd * 100).toFixed(2)}%</td>
                        <td>${(data.stats.long_short_max_dd * 100).toFixed(2)}%</td>
                    </tr>
                </tbody>
            </table>
        `;
        document.getElementById('long-short-table').innerHTML = table;
        } catch (error) {
            console.error('Long-Short Performance Failed to load:', error);
            document.getElementById('long-short-chart').innerHTML = '<p class="text-danger text-center py-5">Failed to load</p>';
            document.getElementById('long-short-table').innerHTML = '';
        }
    }

    // 6. Load Factor Clusters Analysis
    async function loadFactorClusters() {
        try {
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/clusters` : '/api/factor-diagnostics/clusters';
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.clusters) {
                console.warn('Factor Clusters Analysis data is empty:', data.error || 'No data');
                document.getElementById('factor-cluster-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                document.getElementById('factor-cluster-table').innerHTML = '';
                document.getElementById('factor-cluster-explanation').innerHTML = '';
                return;
            }
        
        // Create scatter plot (IC vs ICIR)
        const traces = [];
        const categories = ['momentum', 'quality', 'volatility', 'value', 'size'];
        const colors = ['#2196F3', '#9C27B0', '#FF9800', '#4CAF50', '#E91E63'];
        
        categories.forEach((category, idx) => {
            const factors = data.clusters[category] || [];
            if (factors.length > 0) {
                const ic_values = factors.map(f => f.ic_mean || 0);
                const icir_values = factors.map(f => f.icir || 0);
                
                traces.push({
                    x: ic_values,
                    y: icir_values,
                    mode: 'markers',
                    type: 'scatter',
                    name: category.charAt(0).toUpperCase() + category.slice(1),
                    text: factors.map(f => f.name),
                    textposition: 'top center',
                    marker: { size: 12, color: colors[idx] },
                    hovertemplate: '<b>%{text}</b><br>Mean IC: %{x:.4f}<br>ICIR: %{y:.4f}<extra></extra>'
                });
            }
        });
        
        Plotly.newPlot('factor-cluster-chart', traces, {
            title: {
                text: 'Factor Clusters Analysis (IC vs ICIR)',
                font: { size: 18 }
            },
            xaxis: { 
                title: { text: 'Mean IC', font: { size: 14 } },
                titlefont: { size: 14 },
                tickfont: { size: 12 }
            },
            yaxis: { 
                title: { text: 'ICIR', font: { size: 14 } },
                titlefont: { size: 14 },
                tickfont: { size: 12 }
            },
            hovermode: 'closest',
            template: 'plotly_white',
            height: 600,
            margin: { l: 80, r: 50, t: 80, b: 80 },
            legend: {
                font: { size: 12 },
                x: 1.05,
                y: 1,
                xanchor: 'left',
                yanchor: 'top'
            }
        });
        
        // Show factor clusters table
        let tableHtml = '<table class="table table-striped"><thead><tr><th>Category</th><th>Factor</th><th>Mean IC</th><th>ICIR</th><th>t-stat</th></tr></thead><tbody>';
        categories.forEach(category => {
            const factors = data.clusters[category] || [];
            factors.forEach(factor => {
                tableHtml += `<tr>
                    <td><span class="factor-category ${category}">${category}</span></td>
                    <td>${factor.name}</td>
                    <td>${(factor.ic_mean || 0).toFixed(4)}</td>
                    <td>${(factor.icir || 0).toFixed(4)}</td>
                    <td>${(factor.tstat || 0).toFixed(2)}</td>
                </tr>`;
            });
        });
        tableHtml += '</tbody></table>';
        document.getElementById('factor-cluster-table').innerHTML = tableHtml;
        
        // Build explanation section dynamically based on existing categories
        const categoryDescriptions = {
            'momentum': {
                icon: 'fa-chart-line',
                emoji: 'üìà',
                title: 'Momentum Factors',
                class: 'text-primary',
                description: 'Momentum factors capture the tendency of stock prices to continue their trends. Factors include past N-day returns, relative strength indicators, and price trend patterns. <strong>High IC values</strong> indicate that stocks with strong past performance are more likely to continue outperforming. These factors work best when market trends are persistent.'
            },
            'quality': {
                icon: 'fa-gem',
                emoji: 'üíé',
                title: 'Quality Factors',
                class: 'text-purple',
                description: 'Quality factors measure a company\'s financial health and profitability, including ROE, ROA, profit margins, debt ratios, and earnings stability. High-quality companies typically deliver better long-term returns with lower volatility. <strong>Consistently positive IC</strong> suggests that fundamental quality is rewarded over time, suitable for long-term holding strategies.'
            },
            'volatility': {
                icon: 'fa-wave-square',
                emoji: 'üìä',
                title: 'Volatility Factors',
                class: 'text-warning',
                description: 'Volatility factors reflect price uncertainty and risk. Low volatility stocks tend to have lower risk but may miss high-return opportunities. These include historical volatility, downside volatility, and risk-adjusted returns. <strong>Negative IC</strong> may indicate market preference for low-volatility stocks (risk-aversion behavior).'
            },
            'value': {
                icon: 'fa-dollar-sign',
                emoji: 'üí∞',
                title: 'Value Factors',
                class: 'text-success',
                description: 'Value factors identify undervalued stocks using valuation metrics like P/E, P/B, EV/EBITDA, and price-to-sales ratios. Value investing seeks stocks trading below their intrinsic value. <strong>Positive IC</strong> suggests mean reversion exists - cheap stocks tend to appreciate as the market corrects mispricing over time.'
            },
            'size': {
                icon: 'fa-building',
                emoji: 'üè¢',
                title: 'Size Factors',
                class: 'text-danger',
                description: 'Size factors measure company market capitalization. Small-cap stocks typically exhibit higher volatility and potential returns due to the small-cap premium effect observed in long-term data. However, <strong>size effects vary with market cycles</strong> - large caps may outperform during risk-off periods, while small caps excel during risk-on periods.'
            }
        };
        
        // Find which categories actually exist in the data
        const existingCategories = categories.filter(cat => {
            const factors = data.clusters[cat] || [];
            return factors.length > 0;
        });
        
        // Build explanation HTML only for existing categories
        let leftColumnHtml = '';
        let rightColumnHtml = '';
        
        existingCategories.forEach((category, index) => {
            const desc = categoryDescriptions[category];
            if (!desc) return; // Skip if description not defined
            
            const categoryHtml = `
                <h6 class="${desc.class}"><i class="fas ${desc.icon} me-2"></i>${desc.emoji} ${desc.title}</h6>
                <p class="small mb-3">${desc.description}</p>
            `;
            
            // Distribute categories between left and right columns
            if (index < Math.ceil(existingCategories.length / 2)) {
                leftColumnHtml += categoryHtml;
            } else {
                rightColumnHtml += categoryHtml;
            }
        });
        
        // Add chart interpretation guide to the right column
        rightColumnHtml += `
            <h6><i class="fas fa-chart-area me-2"></i>Chart Interpretation Guide</h6>
            <ul class="small">
                <li><strong>X-axis (Mean IC)</strong>: Correlation between factor and future returns. 
                    Absolute value indicates predictive power; higher = stronger signal.</li>
                <li><strong>Y-axis (ICIR)</strong>: Information Ratio = IC mean / IC std, measuring 
                    factor stability over time. Higher ICIR = more consistent performance.</li>
                <li><strong>Top-right quadrant</strong>: Ideal region with both high IC and high ICIR, 
                    indicating effective and stable factors worth including in strategies.</li>
                <li><strong>t-stat</strong>: Statistical significance. |t-stat| > 2 typically indicates 
                    significant factor performance (95% confidence level).</li>
            </ul>
        `;
        
        // Build final explanation HTML
        const explanationHtml = `
            <div class="mt-4 p-4 bg-light rounded">
                <h5><i class="fas fa-info-circle me-2"></i>Factor Cluster Analysis Interpretation</h5>
                <div class="row">
                    <div class="col-md-6">
                        ${leftColumnHtml}
                    </div>
                    <div class="col-md-6">
                        ${rightColumnHtml}
                    </div>
                </div>
            </div>
        `;
        document.getElementById('factor-cluster-explanation').innerHTML = explanationHtml;
        } catch (error) {
            console.error('Factor Clusters AnalysisFailed to load:', error);
            document.getElementById('factor-cluster-chart').innerHTML = '<p class="text-danger text-center py-5">Failed to load</p>';
            document.getElementById('factor-cluster-table').innerHTML = '';
            document.getElementById('factor-cluster-explanation').innerHTML = '';
        }
    }

    // 7. Load Correlation Matrix
    async function loadCorrelationMatrix() {
        try {
            const method = document.getElementById('correlation-method').value;
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/correlation?method=${method}` : `/api/factor-diagnostics/correlation?method=${method}`;
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.factors || data.factors.length === 0) {
                console.warn('Correlation matrix data is empty:', data.error || 'No data');
                document.getElementById('correlation-matrix-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                return;
            }
        
        const trace = {
            z: data.correlation_matrix,
            x: data.factors,
            y: data.factors,
            type: 'heatmap',
            colorscale: 'RdBu',
            zmid: 0,
            colorbar: { title: 'Correlation' }
        };
        
        Plotly.newPlot('correlation-matrix-chart', [trace], {
            title: 'Factor Correlation Matrix',
            template: 'plotly_white',
            width: 800,
            height: 600
        });
        } catch (error) {
            console.error('Correlation matrix failed to load:', error);
            document.getElementById('correlation-matrix-chart').innerHTML = '<p class="text-danger text-center py-5">Failed to load</p>';
        }
    }

    // 8. Load Risk Exposure
    async function loadRiskExposure() {
        try {
            let date = document.getElementById('exposure-date').value;
            if (!date) {
                // If no date selected, use latest date
                try {
                    const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/latest-date` : '/api/factor-diagnostics/latest-date';
                    const response = await fetch(url);
                    const data = await response.json();
                    if (data.date && !data.error) {
                        document.getElementById('exposure-date').value = data.date;
                        date = data.date;
                    } else {
                        const chartEl = document.getElementById('risk-exposure-chart');
                        if (chartEl) {
                            chartEl.innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                        }
                        document.getElementById('risk-exposure-table').innerHTML = '';
                        document.getElementById('risk-exposure-explanation').innerHTML = '';
                        return; // Cannot get date, skip loading
                    }
                } catch (e) {
                    console.error('Failed to get latest date:', e);
                    const chartEl = document.getElementById('risk-exposure-chart');
                    if (chartEl) {
                        chartEl.innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                    }
                    document.getElementById('risk-exposure-table').innerHTML = '';
                    document.getElementById('risk-exposure-explanation').innerHTML = '';
                    return;
                }
            }
            
            const url = API_BASE_URL ? `${API_BASE_URL}/api/factor-diagnostics/risk-exposure?date=${date}` : `/api/factor-diagnostics/risk-exposure?date=${date}`;
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.error || !data.factors || data.factors.length === 0) {
                console.warn('Risk exposure data is empty:', data.error || 'No data');
                document.getElementById('risk-exposure-chart').innerHTML = '<p class="text-muted text-center py-5">No data available</p>';
                document.getElementById('risk-exposure-table').innerHTML = '';
                document.getElementById('risk-exposure-explanation').innerHTML = '';
                return;
            }
            
            const chartEl = document.getElementById('risk-exposure-chart');
            if (!chartEl) {
                console.error('Risk exposure chart element not found');
                return;
            }
            
            // Clear any existing error messages
            chartEl.innerHTML = '';
            
            const trace = {
                x: data.factors,
                y: data.exposures,
                type: 'bar',
                marker: { color: data.exposures.map(e => e > 0 ? '#28a745' : '#dc3545') }
            };
            
            Plotly.newPlot('risk-exposure-chart', [trace], {
                title: `Risk Exposure (Barra-style) - ${date}`,
                xaxis: { title: 'Factor' },
                yaxis: { title: 'Exposure' },
                template: 'plotly_white'
            });
            
            // Show risk exposure table
            let tableHtml = '<table class="table table-striped"><thead><tr><th>Style Factor</th><th>Exposure</th><th>Risk Contribution</th></tr></thead><tbody>';
            data.factors.forEach((factor, idx) => {
                // Risk contribution is already in percentage from backend (0-100), no need to multiply by 100
                const riskContrib = data.risk_contributions[idx];
                tableHtml += `<tr>
                    <td><strong>${factor}</strong></td>
                    <td>${data.exposures[idx].toFixed(4)}</td>
                    <td>${typeof riskContrib === 'number' ? riskContrib.toFixed(2) : '0.00'}%</td>
                </tr>`;
            });
            // Add specific risk row if available
            if (data.specific_risk_contribution !== undefined && data.specific_risk_contribution !== null) {
                tableHtml += `<tr class="table-info">
                    <td><strong>Specific Risk (Idiosyncratic)</strong></td>
                    <td>-</td>
                    <td>${typeof data.specific_risk_contribution === 'number' ? data.specific_risk_contribution.toFixed(2) : '0.00'}%</td>
                </tr>`;
            }
            tableHtml += '</tbody></table>';
            document.getElementById('risk-exposure-table').innerHTML = tableHtml;
            
            // Add/update explanation section (replace existing content to avoid duplicates)
            const explanationHtml = `
                <div class="mt-4 p-4 bg-light rounded">
                    <h5><i class="fas fa-info-circle me-2"></i>Multi-Factor Risk Exposure (Barra-style) - Complete Interpretation</h5>
                    
                    <div class="row mt-3">
                        <div class="col-md-12">
                            <h6><i class="fas fa-book me-2"></i>1. What is Barra-Style Risk Exposure?</h6>
                            <p class="small mb-3">
                                This analysis uses a <strong>Barra-style multi-factor risk model</strong> following industry-standard 
                                principles to decompose portfolio risk into interpretable, independent sources. Unlike simple factor 
                                analysis, this model transforms raw factors into orthogonal style factors that represent distinct 
                                risk dimensions.
                            </p>
                            
                            <h6><i class="fas fa-cogs me-2"></i>2. Methodology: Step-by-Step Process</h6>
                            <ol class="small mb-3">
                                <li><strong>Factor Classification:</strong> Groups 160+ raw factors into 7 economically meaningful 
                                    style buckets (Price/Level, Trend, Momentum, Volatility, Liquidity, Quality/Stability, Custom). 
                                    Alpha factors are excluded (they are signals, not risk factors).</li>
                                <li><strong>Cross-Sectional Normalization:</strong> For each date, factors are winsorized (clipped 
                                    at 1st/99th percentiles) and z-score normalized to ensure comparability across stocks.</li>
                                <li><strong>Fixed PCA Structure (Rolling Window):</strong> Using a rolling window (60-252 days, 
                                    default 126 days), Principal Component Analysis loadings are estimated once and kept fixed 
                                    across all dates. Within each style bucket, the first principal component (PC1) loadings are 
                                    computed from the reference window and applied to all subsequent dates. This ensures <strong>time-stable 
                                    factor definitions</strong>‚Äîthe same raw factors map to the same style factors across time, 
                                    allowing meaningful time-series analysis and consistent risk attribution.</li>
                                <li><strong>Fixed Orthogonalization Matrix:</strong> Using the same rolling window, the Gram-Schmidt 
                                    orthogonalization matrix is estimated once and kept fixed. This ensures style factors are 
                                    consistently orthogonalized across all dates, maintaining independence while preserving temporal 
                                    stability. The orthogonalization order and transformation are fixed based on the reference window.</li>
                                <li><strong>Factor Return Estimation:</strong> Daily factor returns are estimated via cross-sectional 
                                    regression: <code>r_{i,t+1} = Œ£_k (Œ≤_{i,k,t} √ó f_{k,t+1}) + Œµ_{i,t+1}</code>, where exposures (Œ≤) 
                                    are from time t and stock returns (r) are from time t+1 (no look-ahead bias). The factor exposures 
                                    Œ≤_{i,k,t} use the <strong>fixed PCA and orthogonalization structure</strong> estimated from the 
                                    rolling window, ensuring consistency across time.</li>
                                <li><strong>Factor Covariance Matrix:</strong> Time-series covariance of factor returns is estimated 
                                    using EWMA (Exponentially Weighted Moving Average) with Œª=0.94: <code>Œ£_f = Cov(factor_returns)</code>.</li>
                                <li><strong>Risk Decomposition:</strong> Portfolio variance is computed as: 
                                    <code>œÉ¬≤_portfolio = b^T Œ£_f b + œÉ¬≤_specific</code>, where <code>b</code> is the vector of 
                                    portfolio factor exposures.</li>
                            </ol>
                            
                            <h6><i class="fas fa-calculator me-2"></i>3. Key Formulas</h6>
                            <div class="small mb-3" style="background-color: #f8f9fa; padding: 15px; border-radius: 5px; font-family: 'Courier New', monospace;">
                                <p><strong>Portfolio Factor Exposure:</strong></p>
                                <p style="margin-left: 20px;">b_k = Œ£_i (w_i √ó Œ≤_{i,k})</p>
                                <p style="font-size: 0.9em; color: #666;">where w_i is portfolio weight for stock i, Œ≤_{i,k} is factor k exposure for stock i (computed using fixed PCA/orthogonalization structure)</p>
                                
                                <p class="mt-3"><strong>Portfolio Variance:</strong></p>
                                <p style="margin-left: 20px;">œÉ¬≤_portfolio = b^T Œ£_f b + œÉ¬≤_specific</p>
                                <p style="font-size: 0.9em; color: #666;">where Œ£_f is factor return covariance matrix, œÉ¬≤_specific is idiosyncratic risk</p>
                                
                                <p class="mt-3"><strong>Factor Risk Contribution:</strong></p>
                                <p style="margin-left: 20px;">RC_k = (b_k √ó (Œ£_f b)_k) / œÉ¬≤_portfolio √ó 100%</p>
                                <p style="font-size: 0.9em; color: #666;">where (Œ£_f b)_k is the k-th element of the marginal contribution vector</p>
                                
                                <p class="mt-3"><strong>Specific Risk:</strong></p>
                                <p style="margin-left: 20px;">œÉ¬≤_specific = Œ£_i (w_i¬≤ √ó œÉ¬≤_i)</p>
                                <p style="font-size: 0.9em; color: #666;">where œÉ¬≤_i is the residual variance from factor regression for stock i</p>
                            </div>
                            
                            <h6><i class="fas fa-arrow-up me-2"></i>4. Exposure Interpretation</h6>
                            <p class="small mb-2"><strong>Positive Exposure (b_k > 0):</strong></p>
                            <p class="small mb-3" style="margin-left: 20px;">
                                The portfolio is <strong>overweight</strong> in this factor relative to the benchmark. For example, 
                                a positive momentum exposure means the portfolio holds more high-momentum stocks. This can be 
                                intentional to capture momentum effects, but also increases exposure to momentum risk.
                            </p>
                            <p class="small mb-2"><strong>Negative Exposure (b_k < 0):</strong></p>
                            <p class="small mb-3" style="margin-left: 20px;">
                                The portfolio is <strong>underweight</strong> in this factor. For example, a negative value exposure 
                                means the portfolio prefers growth stocks over value stocks. Negative exposures can serve as hedges 
                                but also represent missed opportunities if the factor performs well.
                            </p>
                            
                            <h6><i class="fas fa-percentage me-2"></i>5. Risk Contribution Interpretation</h6>
                            <p class="small mb-2"><strong>Positive Risk Contribution (RC_k > 0):</strong></p>
                            <p class="small mb-3" style="margin-left: 20px;">
                                This factor <strong>increases</strong> portfolio variance. The magnitude |RC_k| shows what percentage 
                                of total portfolio risk is attributed to this factor. Higher positive contributions indicate the 
                                factor is a major driver of portfolio volatility.
                            </p>
                            <p class="small mb-2"><strong>Negative Risk Contribution (RC_k < 0):</strong></p>
                            <p class="small mb-3" style="margin-left: 20px;">
                                This factor <strong>reduces</strong> portfolio variance (hedging effect). This occurs when the factor 
                                exposure (b_k) and marginal contribution ((Œ£_f b)_k) have opposite signs. The magnitude |RC_k| still 
                                represents the factor's impact magnitude, but the negative sign indicates risk reduction rather than 
                                risk addition. This is mathematically valid and indicates the factor acts as a natural hedge.
                            </p>
                            <p class="small mb-3" style="background-color: #fff3cd; padding: 10px; border-radius: 5px; border-left: 4px solid #ffc107;">
                                <strong>Important:</strong> Risk contributions sum to 100% (including specific risk). The sign indicates 
                                direction (risk addition vs. reduction), while the absolute value indicates magnitude. A negative 
                                contribution means the factor is reducing portfolio risk, not that risk is negative.
                            </p>
                            
                            <h6><i class="fas fa-chart-line me-2"></i>6. Specific Risk</h6>
                            <p class="small mb-3">
                                <strong>Specific Risk (œÉ¬≤_specific)</strong> represents idiosyncratic (stock-specific) risk that cannot 
                                be explained by systematic style factors. It captures company-specific events, earnings surprises, 
                                management changes, and other non-systematic risks. For a well-diversified portfolio with N stocks, 
                                specific risk contribution typically decreases as 1/N due to diversification. A high specific risk 
                                contribution (>20%) may indicate insufficient diversification or concentrated positions.
                            </p>
                            
                            <h6><i class="fas fa-lightbulb me-2"></i>7. How to Use This Analysis</h6>
                            <ul class="small">
                                <li><strong>Identify Concentration Risk:</strong> If one factor accounts for >50% of absolute risk 
                                    contribution, consider diversifying to reduce concentration. High concentration increases 
                                    vulnerability to that factor's performance.</li>
                                <li><strong>Monitor Factor Drift:</strong> Track exposure changes over time. Large shifts may indicate 
                                    unintended style drift or market-driven changes requiring rebalancing.</li>
                                <li><strong>Understand Hedging Effects:</strong> Negative risk contributions indicate natural hedges. 
                                    Ensure these are intentional rather than accidental, and consider if they align with your strategy.</li>
                                <li><strong>Factor Timing:</strong> Adjust exposures based on market conditions. For example, increase 
                                    quality exposure during market stress, or momentum exposure during trending markets.</li>
                                <li><strong>Rebalancing Signal:</strong> Large exposure or risk contribution changes may indicate the 
                                    need for portfolio rebalancing to maintain target factor weights and risk budget.</li>
                                <li><strong>Risk Budgeting:</strong> Use risk contributions to allocate risk budget across factors. 
                                    Ensure no single factor dominates unless intentional (e.g., factor-tilting strategies).</li>
                            </ul>
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('risk-exposure-explanation').innerHTML = explanationHtml;
        } catch (error) {
            console.error('Risk exposure failed to load:', error);
            document.getElementById('risk-exposure-chart').innerHTML = '<p class="text-danger text-center py-5">Failed to load</p>';
            document.getElementById('risk-exposure-table').innerHTML = '';
            document.getElementById('risk-exposure-explanation').innerHTML = '';
        }
    }
</script>
{% endblock %}

